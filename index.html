<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cricket Player Auction Card</title>
  
  <!-- Favicon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèè</text></svg>">
  
  <!-- DNS Prefetch for faster image loading -->
  <link rel="dns-prefetch" href="//drive.google.com">
  <link rel="dns-prefetch" href="//ui-avatars.com">
  
  <!-- Preconnect to image sources -->
  <link rel="preconnect" href="https://drive.google.com">
  <link rel="preconnect" href="https://ui-avatars.com">
  
  <!-- Preload critical background image -->
  <link rel="preload" as="image" href="./assets/BG.jpg">
  
  <style>
    /* Basic reset & container */
    body, html {
      margin: 0;
      padding: 0;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      background: #0a0a0a;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    
    /* Fullscreen notification */
    .fullscreen-notification {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.95), rgba(21, 101, 192, 0.95));
      color: #fff;
      padding: 20px 50px;
      border-radius: 50px;
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      box-shadow: 0 10px 40px rgba(33, 150, 243, 0.6),
                  0 0 60px rgba(33, 150, 243, 0.4),
                  inset 0 0 20px rgba(255, 255, 255, 0.2);
      z-index: 10000;
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events: none;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .fullscreen-notification.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    
    .fullscreen-notification::before {
      content: '‚åß';
      margin-right: 15px;
      font-size: 28px;
      display: inline-block;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.2);
      }
    }
    
    /* General notification styles */
    .notification {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      padding: 16px 40px;
      border-radius: 30px;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 1px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                  inset 0 0 20px rgba(255, 255, 255, 0.15);
      z-index: 9999;
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      pointer-events: none;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      max-width: 600px;
      text-align: center;
    }
    
    .notification.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    
    .notification.info {
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.95), rgba(21, 101, 192, 0.95));
      box-shadow: 0 8px 32px rgba(33, 150, 243, 0.5),
                  inset 0 0 20px rgba(255, 255, 255, 0.15);
    }
    
    .notification.warning {
      background: linear-gradient(135deg, rgba(255, 152, 0, 0.95), rgba(245, 124, 0, 0.95));
      box-shadow: 0 8px 32px rgba(255, 152, 0, 0.5),
                  inset 0 0 20px rgba(255, 255, 255, 0.15);
    }
    
    .notification.error {
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.95), rgba(211, 47, 47, 0.95));
      box-shadow: 0 8px 32px rgba(244, 67, 54, 0.5),
                  inset 0 0 20px rgba(255, 255, 255, 0.15);
    }
    
    .notification.success {
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(56, 142, 60, 0.95));
      box-shadow: 0 8px 32px rgba(76, 175, 80, 0.5),
                  inset 0 0 20px rgba(255, 255, 255, 0.15);
    }
    
    /* Container wrapper for scaling */
    .card-wrapper {
      transform: scale(0.8);
      transform-origin: center center;
      transition: transform 0.3s ease;
    }
    
    /* Fullscreen mode - fill entire screen */
    :fullscreen .card-wrapper,
    :-webkit-full-screen .card-wrapper,
    :-moz-full-screen .card-wrapper,
    :-ms-fullscreen .card-wrapper {
      transform: scale(1);
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    :fullscreen .card,
    :-webkit-full-screen .card,
    :-moz-full-screen .card,
    :-ms-fullscreen .card {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      border-radius: 0;
      box-shadow: none;
    }
    
    .card {
      position: relative;
      width: 2060px;
      height: 1080px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-color: #0a0a0a;
      border-radius: 0px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      overflow: hidden;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 80px;
    }
    
    .card.blur-background .profile-container,
    .card.blur-background .bid-display,
    .card.blur-background .player-id-badge {
      filter: blur(15px);
      transition: filter 0.5s ease;
    }
    
    .card.blur-background::before {
      backdrop-filter: blur(10px);
    }
    
    /* Dark overlay for better text visibility - removed */
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: transparent;
      z-index: 1;
    }
    
    /* Circular Profile Container */
    .profile-container {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 40px;
      width: 100%;
      max-width: 800px;
    }
    
    /* Circular Profile Image */
    .profile-circle {
      position: relative;
      width: 590px;
      height: 590px;
      border-radius: 50%;
      overflow: hidden;
      box-shadow: 0 15px 40px rgba(33, 150, 243, 0.5),
                  0 0 0 15px rgba(33, 150, 243, 0.15);
      background: #1a1a1a;
      flex-shrink: 0;
    }
    
    .profile-circle img {
      width: 100%;
      height: 190%;
      object-fit: cover;
      margin-top: -70px;
      opacity: 0;
      animation: fadeInImage 0.3s ease-in forwards;
    }
    
    @keyframes fadeInImage {
      to {
        opacity: 1;
      }
    }
    
    .player-id-badge {
      position: absolute;
      top: 190px;
      right: 310px;
      color: #FFF;
      font-size: 128px;
      font-weight: 900;
      z-index: 10;
      letter-spacing: 2px;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.9), 0 0 20px rgba(33, 150, 243, 0.6);
    }
    
    /* Player Info Section */
    .player-info-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 25px;
      width: 100%;
      max-width: 750px;
    }
    
    .player-name {
      font-size: 60px;
      font-weight: 900;
      color: #2196F3;
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.9),
                   0 0 25px rgba(33, 150, 243, 0.6);
      line-height: 1.2;
      text-align: center;
    }
    
    .info-grid {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 100%;
    }
    
    .info-item {
      background: rgba(0, 0, 0, 0.75);
      border-left: 6px solid #2196F3;
      padding: 20px 35px;
      border-radius: 10px;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
      text-align: center;
    }
    
    .info-item:hover {
      background: rgba(33, 150, 243, 0.25);
      transform: scale(1.02);
    }
    
    .info-label {
      font-size: 24px;
      color: #bbb;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 5px;
      font-weight: 600;
    }
    
    .info-value {
      font-size: 40px;
      color: #fff;
      font-weight: 700;
      letter-spacing: 1px;
      text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
    }
    
    .role-value {
      color: #c9e7ff;
      font-size: 40px;
    }
    
    .stats-highlight {
      display: flex;
      gap: 25px;
      width: 1440px;
      height: 120px;
    }
    
    .stat-box {
      flex: 1;
      text-align: center;
      padding: 18px 20px;
      border-radius: 15px;
    }
    
    .stat-label {
      font-size: 22px;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .stat-value {
      font-size: 42px;
      color: #fff;
      font-weight: 900;
      text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
    }
    
    .footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 25px;
      background: rgba(0,0,0,0.9);
      text-align: center;
      font-size: 28px;
      font-weight: bold;
      color: #2196F3;
      letter-spacing: 2px;
      border-top: 3px solid #2196F3;
    }
    
    /* Bid Amount Display */
    .bid-display {
      position: absolute;
      bottom: 220px;
      right: 80px;
      z-index: 100;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      border: 3px solid #2196F3;
      border-radius: 20px;
      padding: 12px 16px;
      box-shadow: 0 8px 30px rgba(33, 150, 243, 0.4),
                  0 0 0 6px rgba(33, 150, 243, 0.1);
      min-width: 280px;
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.3s ease;
    }
    
    .bid-team-logo-container {
      position: relative;
      width: 60px;
      height: 60px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .bid-team-logo {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      padding: 8px;
      position: relative;
      z-index: 2;
      animation: logoEntrance 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .bid-team-pulse {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(33, 150, 243, 0.4) 0%, transparent 70%);
      animation: pulsate 2s ease-out infinite;
      z-index: 1;
      display: none;
    }
    
    .bid-team-logo-container.active .bid-team-pulse {
      display: block;
    }
    
    .bid-content {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .bid-label {
      font-size: 12px;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 3px;
      font-weight: 600;
    }
    
    .bid-amount {
      font-size: 36px;
      color: #2196F3;
      font-weight: 900;
      letter-spacing: 1px;
      text-shadow: 0 0 20px rgba(33, 150, 243, 0.6);
      line-height: 1;
      margin-bottom: 3px;
    }
    
    .bid-team-name {
      font-size: 12px;
      color: #2196F3;
      font-weight: 700;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      margin-bottom: 5px;
      animation: slideInRight 0.4s ease-out;
    }
    
    .bid-increment-info {
      position: absolute;
      bottom: 15px;
      right: 15px;
      z-index: 50;
      font-size: 10px;
      color: #555;
      letter-spacing: 0.5px;
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(33, 150, 243, 0.2);
      backdrop-filter: blur(5px);
      opacity: 0.7;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .bid-increment-info:hover {
      opacity: 1;
      transform: scale(1.05);
    }
    
    .increment-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }
    
    .increment-controls kbd {
      background: linear-gradient(135deg, #555 0%, #333 100%);
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: 700;
      font-family: 'Courier New', monospace;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }
    
    .increment-value {
      color: #2196F3;
      font-weight: 900;
      font-size: 11px;
      padding: 0 3px;
      text-shadow: 0 0 8px rgba(33, 150, 243, 0.4);
      min-width: 50px;
      text-align: center;
      display: inline-block;
    }
    
    .increment-arrow,
    .decrement-arrow {
      color: #777;
      font-size: 8px;
    }
    
    .bid-increment-info.updated {
      opacity: 1;
      transform: scale(1.1);
    }
    
    .bid-increment-info.updated .increment-value {
      animation: incrementFlash 0.3s ease-out;
    }
    
    /* Team Status Indicator (Bottom Left Corner) */
    .team-status-indicator {
      position: absolute;
      bottom: 15px;
      left: 15px;
      z-index: 50;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-width: 250px;
      opacity: 0.9;
      transition: opacity 0.3s ease;
      padding: 10px;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    
    .team-status-indicator:hover {
      opacity: 1;
    }
    
    .team-status-item {
      position: relative;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      overflow: visible;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 3px solid transparent;
    }
    
    .team-status-item:hover {
      transform: scale(1.15);
    }
    
    .team-status-item.status-safe {
      background: rgba(76, 175, 80, 0.4);
      border-color: #4CAF50;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.7),
                  0 0 25px rgba(76, 175, 80, 0.4),
                  inset 0 0 10px rgba(76, 175, 80, 0.2);
      animation: statusGlowSafe 2s ease-in-out infinite;
    }
    
    .team-status-item.status-warning {
      background: rgba(255, 152, 0, 0.35);
      border-color: #ff9800;
      box-shadow: 0 0 15px rgba(255, 152, 0, 0.6),
                  0 0 25px rgba(255, 152, 0, 0.35),
                  inset 0 0 10px rgba(255, 152, 0, 0.15);
      animation: statusGlowWarning 2s ease-in-out infinite;
    }
    
    .team-status-item.status-warning .team-status-logo {
      opacity: 0.6;
    }
    
    .team-status-item.status-danger {
      background: rgba(244, 67, 54, 0.85);
      border-color: #f44336;
      box-shadow: 0 0 18px rgba(244, 67, 54, 0.9),
                  0 0 30px rgba(244, 67, 54, 0.6),
                  inset 0 0 15px rgba(244, 67, 54, 0.4);
      animation: statusGlowDanger 2s ease-in-out infinite;
    }
    
    .team-status-item.status-danger .team-status-logo {
      opacity: 0.2;
      filter: brightness(0.3);
    }
    
    .team-status-logo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      position: relative;
      z-index: 1;
      transition: opacity 0.3s ease, filter 0.3s ease;
    }
    
    .team-status-number {
      position: absolute;
      bottom: -2px;
      right: -2px;
      width: 16px;
      height: 16px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      font-size: 9px;
      font-weight: 900;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid rgba(255, 255, 255, 0.6);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      z-index: 2;
    }
    
    .team-status-tooltip {
      position: absolute;
      bottom: 45px;
      left: 50%;
      transform: translateX(-50%) scale(0);
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 10px;
      white-space: nowrap;
      pointer-events: none;
      transition: transform 0.2s ease, opacity 0.2s ease;
      opacity: 0;
      z-index: 100;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .team-status-item:hover .team-status-tooltip {
      transform: translateX(-50%) scale(1);
      opacity: 1;
    }
    
    @keyframes statusGlowSafe {
      0%, 100% {
        background: rgba(76, 175, 80, 0.35);
        box-shadow: 0 0 12px rgba(76, 175, 80, 0.6),
                    0 0 20px rgba(76, 175, 80, 0.3),
                    inset 0 0 10px rgba(76, 175, 80, 0.2);
      }
      50% {
        background: rgba(76, 175, 80, 0.5);
        box-shadow: 0 0 18px rgba(76, 175, 80, 0.9),
                    0 0 30px rgba(76, 175, 80, 0.5),
                    inset 0 0 15px rgba(76, 175, 80, 0.3);
      }
    }
    
    @keyframes statusGlowWarning {
      0%, 100% {
        background: rgba(255, 152, 0, 0.3);
        box-shadow: 0 0 12px rgba(255, 152, 0, 0.5),
                    0 0 20px rgba(255, 152, 0, 0.25),
                    inset 0 0 10px rgba(255, 152, 0, 0.15);
      }
      50% {
        background: rgba(255, 152, 0, 0.45);
        box-shadow: 0 0 18px rgba(255, 152, 0, 0.8),
                    0 0 30px rgba(255, 152, 0, 0.4),
                    inset 0 0 15px rgba(255, 152, 0, 0.25);
      }
    }
    
    @keyframes statusGlowDanger {
      0%, 100% {
        background: rgba(244, 67, 54, 0.8);
        box-shadow: 0 0 15px rgba(244, 67, 54, 0.85),
                    0 0 25px rgba(244, 67, 54, 0.5),
                    inset 0 0 12px rgba(244, 67, 54, 0.35);
      }
      50% {
        background: rgba(244, 67, 54, 0.95);
        box-shadow: 0 0 22px rgba(244, 67, 54, 1),
                    0 0 35px rgba(244, 67, 54, 0.7),
                    inset 0 0 18px rgba(244, 67, 54, 0.5);
      }
    }
    
    @keyframes incrementFlash {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.3);
        color: #4CAF50;
        text-shadow: 0 0 12px rgba(76, 175, 80, 0.8);
      }
    }
    
    .bid-display.pulse {
      animation: bidPulse 0.3s ease-out;
    }
    
    /* Color feedback for bid display (when notifications are disabled) */
    .bid-display.feedback-info {
      border-color: #2196F3;
      box-shadow: 0 8px 30px rgba(33, 150, 243, 0.8),
                  0 0 0 6px rgba(33, 150, 243, 0.3);
      animation: feedbackPulse 0.6s ease-out;
    }
    
    .bid-display.feedback-success {
      border-color: #4CAF50;
      box-shadow: 0 8px 30px rgba(76, 175, 80, 0.8),
                  0 0 0 6px rgba(76, 175, 80, 0.3);
      animation: feedbackPulse 0.6s ease-out;
    }
    
    .bid-display.feedback-warning {
      border-color: #FF9800;
      box-shadow: 0 8px 30px rgba(255, 152, 0, 0.8),
                  0 0 0 6px rgba(255, 152, 0, 0.3);
      animation: feedbackPulse 0.6s ease-out;
    }
    
    .bid-display.feedback-error {
      border-color: #F44336;
      box-shadow: 0 8px 30px rgba(244, 67, 54, 0.8),
                  0 0 0 6px rgba(244, 67, 54, 0.3);
      animation: feedbackPulse 0.6s ease-out;
    }
    
    @keyframes bidPulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 10px 50px rgba(33, 150, 243, 0.8),
                    0 0 0 8px rgba(33, 150, 243, 0.3);
      }
    }
    
    @keyframes feedbackPulse {
      0%, 100% {
        transform: scale(1);
      }
      30% {
        transform: scale(1.08);
      }
      60% {
        transform: scale(0.98);
      }
    }
    
    @keyframes logoEntrance {
      0% {
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }
      60% {
        transform: scale(1.2) rotate(20deg);
      }
      100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }
    
    @keyframes pulsate {
      0% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.6;
      }
      50% {
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 0.3;
      }
      100% {
        transform: translate(-50%, -50%) scale(1.6);
        opacity: 0;
      }
    }
    
    @keyframes slideInRight {
      0% {
        transform: translateX(-20px);
        opacity: 0;
      }
      100% {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    /* Team Selection Modal */
    .team-selection-modal {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.95);
      padding: 40px;
      z-index: 2000;
      transform: translateY(100%);
      transition: transform 0.4s ease-out;
      backdrop-filter: blur(10px);
      border-top: 4px solid #2196F3;
    }
    
    .team-selection-modal.show {
      transform: translateY(0);
    }
    
    .team-modal-content {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 25px;
    }
    
    .team-modal-title {
      font-size: 42px;
      color: #2196F3;
      font-weight: 900;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-bottom: 10px;
    }
    
    .team-dropdown-container {
      display: flex;
      align-items: center;
      gap: 30px;
      justify-content: center;
    }
    
    .team-dropdown-label {
      font-size: 32px;
      color: #fff;
      font-weight: 600;
    }
    
    .team-dropdown {
      flex: 1;
      max-width: 600px;
      padding: 20px 30px;
      font-size: 28px;
      background: rgba(33, 150, 243, 0.1);
      color: #fff;
      border: 3px solid #2196F3;
      border-radius: 15px;
      cursor: pointer;
      outline: none;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    .team-dropdown option {
      background: #1a1a1a;
      color: #fff;
      padding: 15px;
    }
    
    .team-dropdown:hover {
      background: rgba(33, 150, 243, 0.2);
      box-shadow: 0 0 20px rgba(33, 150, 243, 0.5);
    }
    
    .team-modal-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 20px;
    }
    
    .team-modal-btn {
      padding: 18px 50px;
      font-size: 28px;
      font-weight: bold;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.3s ease;
    }
    
    .team-modal-btn.confirm {
      background: #4CAF50;
      color: white;
      box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
    }
    
    .team-modal-btn.confirm:hover {
      background: #45a049;
      transform: scale(1.05);
    }
    
    .team-modal-btn.cancel {
      background: #f44336;
      color: white;
      box-shadow: 0 5px 20px rgba(244, 67, 54, 0.4);
    }
    
    .team-modal-btn.cancel:hover {
      background: #da190b;
      transform: scale(1.05);
    }
    
    /* Animation for sold overlay */
    .sold-overlay {
      position: absolute;
      top:0; left:0;
      width:100%; height:100%;
      background: linear-gradient(135deg, rgba(27, 94, 32, 0.25) 0%, rgba(76, 175, 80, 0.2) 100%);
      display: flex;
      flex-direction: column;
      align-items:center;
      justify-content:center;
      font-size: 48px;
      color: #d00;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
      z-index: 9999;
      backdrop-filter: blur(25px) saturate(150%);
      overflow: hidden;
    }
    
    .sold-overlay::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: 
        radial-gradient(circle at 30% 30%, rgba(76, 175, 80, 0.4) 0%, transparent 40%),
        radial-gradient(circle at 70% 70%, rgba(139, 195, 74, 0.35) 0%, transparent 40%),
        radial-gradient(circle at 50% 50%, rgba(46, 125, 50, 0.3) 0%, transparent 50%);
      animation: greenFlow 6s ease-in-out infinite;
      z-index: -1;
    }
    
    @keyframes greenFlow {
      0% {
        transform: translate(0, 0) rotate(0deg);
      }
      50% {
        transform: translate(10%, 10%) rotate(180deg);
      }
      100% {
        transform: translate(0, 0) rotate(360deg);
      }
    }
    
    .sold-overlay.show {
      opacity:1;
    }
    
    .sold-overlay.show::before {
      animation-play-state: running;
    }
    
    /* Circular stamp design - Apple style */
    .stamp {
      position: relative;
      width: 450px;
      height: 450px;
      border: 12px solid #fff;
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, rgba(20, 20, 20, 0.40) 0%, rgba(10, 10, 10, 0.50) 100%);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.5),
                  0 30px 80px rgba(0, 0, 0, 0.4);
      opacity: 0;
      transform: scale(0) rotate(-30deg);
      z-index: 10002;
    }
    
    .stamp-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(0, 0, 0, 0.30) 0%, rgba(0, 0, 0, 0.50) 100%);
      border-radius: 50%;
      backdrop-filter: blur(1px);
    }
    
    .stamp.stamping {
      animation: stampPressApple 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }
    
    @keyframes stampPressApple {
      0% {
        opacity: 1;
        transform: scale(0.3) rotate(-30deg);
        box-shadow: 0 0 0 0 rgba(220, 0, 0, 0.5),
                    0 15px 40px rgba(0, 0, 0, 0.1);
      }
      15% {
        opacity: 1;
        transform: scale(0.5) rotate(-20deg);
        box-shadow: 0 0 0 0 rgba(220, 0, 0, 0.6),
                    0 20px 50px rgba(0, 0, 0, 0.15);
      }
      35% {
        opacity: 1;
        transform: scale(0.85) rotate(-5deg);
        box-shadow: 0 0 0 0 rgba(220, 0, 0, 0.7),
                    0 25px 60px rgba(0, 0, 0, 0.2);
      }
      50% {
        opacity: 1;
        transform: scale(1.15) rotate(3deg);
        box-shadow: 0 0 0 10px rgba(220, 0, 0, 0.8),
                    0 30px 80px rgba(0, 0, 0, 0.25);
      }
      65% {
        transform: scale(0.92) rotate(-1deg);
        box-shadow: 0 0 0 40px rgba(220, 0, 0, 0.6),
                    0 35px 90px rgba(0, 0, 0, 0.3);
      }
      80% {
        transform: scale(1.03) rotate(1deg);
        box-shadow: 0 0 0 60px rgba(220, 0, 0, 0.3),
                    0 30px 80px rgba(0, 0, 0, 0.25);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
        box-shadow: 0 0 0 80px rgba(220, 0, 0, 0),
                    0 25px 70px rgba(0, 0, 0, 0.2);
      }
    }

    .stamp-text-container {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* Top arc text - PLAYER */
    .stamp-text-top {
      position: absolute;
      top: 45px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 8px;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      text-transform: uppercase;
      text-shadow: 3px 3px 10px rgba(0, 0, 0, 1), 
                   0 0 15px rgba(0, 0, 0, 0.9),
                   0 0 25px rgba(255, 255, 255, 0.2);
      z-index: 10;
    }
    
    /* Center main text - SOLD */
    .stamp-text-main {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      font-weight: 900;
      letter-spacing: 6px;
      color: #fff;
      line-height: 1;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', Impact, 'Arial Black', sans-serif;
      text-transform: uppercase;
      text-shadow: 4px 4px 15px rgba(0, 0, 0, 1), 
                   0 0 30px rgba(255, 255, 255, 0.4),
                   0 0 50px rgba(255, 255, 255, 0.2);
      z-index: 5;
      opacity: 0.9;
    }
    
    /* Bottom arc text - TO */
    .stamp-text-bottom {
      position: absolute;
      bottom: 130px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 6px;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      text-transform: uppercase;
      text-shadow: 3px 3px 10px rgba(0, 0, 0, 1), 
                   0 0 15px rgba(0, 0, 0, 0.9),
                   0 0 25px rgba(255, 255, 255, 0.2);
      z-index: 10;
    }
    
    /* Team name - Lower center with blur effect */
    .stamp-text-team {
      position: absolute;
      bottom: 55px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      font-weight: 900;
      letter-spacing: 3px;
      color: #FFD700;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      text-align: center;
      max-width: 75%;
      line-height: 1.2;
      text-transform: uppercase;
      text-shadow: 3px 3px 12px rgba(0, 0, 0, 1), 
                   0 0 20px rgba(255, 215, 0, 0.9),
                   0 0 40px rgba(255, 215, 0, 0.6),
                   0 0 60px rgba(255, 215, 0, 0.3);
      z-index: 15;
      padding: 15px 35px;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(15px) saturate(180%);
      -webkit-backdrop-filter: blur(15px) saturate(180%);
      border-radius: 25px;
      border: 3px solid rgba(255, 215, 0, 0.5);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9),
                  0 0 30px rgba(255, 215, 0, 0.4),
                  inset 0 0 30px rgba(255, 215, 0, 0.15),
                  inset 0 -5px 20px rgba(255, 215, 0, 0.1);
      animation: teamNameGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes teamNameGlow {
      0% {
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9),
                    0 0 30px rgba(255, 215, 0, 0.4),
                    inset 0 0 30px rgba(255, 215, 0, 0.15);
      }
      100% {
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9),
                    0 0 50px rgba(255, 215, 0, 0.6),
                    inset 0 0 40px rgba(255, 215, 0, 0.25);
      }
    }
    
    /* Stamp border decoration */
    .stamp::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px dashed rgba(255, 255, 255, 0.5);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px;
      z-index: 1;
    }
    
    /* Hammer animation - Apple style with realistic impact and exit */
    .hammer {
      position: absolute;
      font-size: 140px;
      top: -200px;
      left: 50%;
      transform: translateX(-50%) rotate(-35deg);
      opacity: 0;
      z-index: 10003;
      filter: drop-shadow(0 15px 40px rgba(0, 0, 0, 0.4));
    }
    .hammer.strike {
      animation: hammerStrikeApple 1.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    }
    @keyframes hammerStrikeApple {
      0% {
        top: -200px;
        opacity: 0;
        transform: translateX(-50%) rotate(-35deg) scale(1);
      }
      18% {
        opacity: 1;
        transform: translateX(-50%) rotate(-35deg) scale(1.1);
      }
      32% {
        top: 42%;
        opacity: 1;
        transform: translateX(-50%) rotate(-12deg) scale(1.15);
      }
      40% {
        top: 48%;
        transform: translateX(-50%) rotate(-3deg) scale(1.2);
      }
      45% {
        top: 50%;
        transform: translateX(-50%) rotate(0deg) scale(1.25);
      }
      50% {
        top: 51%;
        transform: translateX(-50%) rotate(2deg) scale(1.23);
      }
      55% {
        top: 50%;
        opacity: 1;
        transform: translateX(-50%) rotate(0deg) scale(1.2);
      }
      62% {
        top: 49%;
        opacity: 0.9;
        transform: translateX(-50%) rotate(-8deg) scale(1.15);
      }
      70% {
        top: 45%;
        opacity: 0.7;
        transform: translateX(-50%) rotate(-20deg) scale(1.1);
      }
      82% {
        top: 20%;
        opacity: 0.3;
        transform: translateX(-50%) rotate(-40deg) scale(0.95);
      }
      100% {
        top: -200px;
        opacity: 0;
        transform: translateX(-50%) rotate(-50deg) scale(0.8);
      }
    }
    
    /* Screen impact shake effect */
    @keyframes screenShake {
      0%, 100% { transform: translate(0, 0); }
      10%, 30%, 50%, 70%, 90% { transform: translate(-2px, 2px); }
      20%, 40%, 60%, 80% { transform: translate(2px, -2px); }
    }
    
    .sold-overlay.impact {
      animation: screenShake 0.3s cubic-bezier(0.36, 0.07, 0.19, 0.97);
    }
    
    /* Unsold overlay */
    .unsold-overlay {
      position: absolute;
      top:0; left:0;
      width:100%; height:100%;
      background: rgba(20,20,20,0.95);
      display: flex;
      align-items:center;
      justify-content:center;
      flex-direction: column;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease-in;
      z-index: 1000;
    }
    .unsold-overlay.show {
      opacity:1;
    }
    
    /* X mark animation */
    .unsold-x {
      position: relative;
      width: 400px;
      height: 400px;
      margin-bottom: 40px;
      opacity: 0;
    }
    
    .unsold-x.animate {
      animation: xAppear 0.3s ease-out forwards;
    }
    
    @keyframes xAppear {
      to { opacity: 1; }
    }
    
    .unsold-x::before,
    .unsold-x::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 30px;
      background: #ff4444;
      border-radius: 15px;
      box-shadow: 0 0 30px rgba(255,68,68,0.8);
    }
    
    .unsold-x::before {
      transform: translate(-50%, -50%) rotate(45deg);
    }
    
    .unsold-x::after {
      transform: translate(-50%, -50%) rotate(-45deg);
    }
    
    .unsold-x.animate::before,
    .unsold-x.animate::after {
      animation: drawX 0.5s ease-out 0.2s forwards;
    }
    
    @keyframes drawX {
      to {
        width: 400px;
      }
    }
    
    .unsold-text {
      position: relative;
      font-size: 120px;
      font-weight: 900;
      color: #ff4444;
      text-transform: uppercase;
      letter-spacing: 20px;
      opacity: 0;
      transform: scale(0.5);
      text-shadow: 0 0 40px rgba(255,68,68,0.8),
                   0 0 80px rgba(255,68,68,0.4);
      font-family: Impact, 'Arial Black', sans-serif;
    }
    
    .unsold-text.animate {
      animation: unsoldPop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) 0.5s forwards;
    }
    
    @keyframes unsoldPop {
      0% {
        opacity: 0;
        transform: scale(0.5) rotate(-10deg);
      }
      50% {
        transform: scale(1.1) rotate(5deg);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
    }
    
    .unsold-subtext {
      font-size: 48px;
      color: #ff6666;
      margin-top: 20px;
      opacity: 0;
      letter-spacing: 8px;
      font-weight: 600;
    }
    
    .unsold-subtext.animate {
      animation: fadeInUp 0.5s ease-out 0.8s forwards;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Coin Jar Random Selection Overlay */
    .coin-jar-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(10, 10, 10, 0.98) 0%, rgba(20, 20, 20, 0.95) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
    }
    
    .coin-jar-overlay.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .coin-jar-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
    }
    
    .coin-jar {
      position: relative;
      width: 400px;
      height: 500px;
      perspective: 1000px;
      transform-style: preserve-3d;
      transition: transform 0.3s ease-out;
    }
    
    .coin-jar.shaking {
      animation: jarContainerShake 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) infinite;
    }
    
    @keyframes jarContainerShake {
      0% { 
        transform: rotateZ(0deg) translateY(0) translateX(0) scale(1); 
      }
      8% { 
        transform: rotateZ(-10deg) translateY(-8px) translateX(-5px) scale(1.01); 
      }
      16% { 
        transform: rotateZ(-6deg) translateY(10px) translateX(-4px) scale(0.99); 
      }
      24% { 
        transform: rotateZ(10deg) translateY(-7px) translateX(5px) scale(1.01); 
      }
      32% { 
        transform: rotateZ(7deg) translateY(11px) translateX(4px) scale(0.98); 
      }
      40% { 
        transform: rotateZ(-12deg) translateY(-9px) translateX(-6px) scale(1.02); 
      }
      48% { 
        transform: rotateZ(-8deg) translateY(12px) translateX(-5px) scale(0.99); 
      }
      56% { 
        transform: rotateZ(12deg) translateY(-6px) translateX(6px) scale(1.01); 
      }
      64% { 
        transform: rotateZ(8deg) translateY(9px) translateX(5px) scale(0.99); 
      }
      72% { 
        transform: rotateZ(-8deg) translateY(-5px) translateX(-4px) scale(1); 
      }
      80% { 
        transform: rotateZ(-4deg) translateY(6px) translateX(-3px) scale(0.99); 
      }
      88% { 
        transform: rotateZ(4deg) translateY(-3px) translateX(3px) scale(1); 
      }
      96% { 
        transform: rotateZ(2deg) translateY(2px) translateX(2px) scale(1); 
      }
      100% { 
        transform: rotateZ(0deg) translateY(0) translateX(0) scale(1); 
      }
    }
    
    .jar-body {
      position: relative;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 380px;
      height: 380px;
      background: radial-gradient(ellipse at center, 
        rgba(100, 180, 220, 0.25) 0%, 
        rgba(80, 150, 200, 0.3) 40%,
        rgba(70, 130, 180, 0.35) 70%,
        rgba(60, 120, 170, 0.4) 100%);
      border: 10px solid rgba(150, 200, 230, 0.5);
      border-radius: 50%;
      box-shadow: 
        inset 0 0 80px rgba(255, 255, 255, 0.15),
        inset -30px -30px 60px rgba(100, 150, 200, 0.2),
        inset 30px 30px 60px rgba(120, 180, 220, 0.15),
        0 30px 80px rgba(0, 0, 0, 0.6),
        0 15px 40px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(8px);
      overflow: hidden;
      transform-style: preserve-3d;
    }
    
    .jar-body::before {
      content: '';
      position: absolute;
      top: 8%;
      left: 12%;
      width: 35%;
      height: 50%;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.4) 0%, 
        rgba(255, 255, 255, 0.2) 50%,
        transparent 100%);
      border-radius: 50%;
      filter: blur(25px);
      transform: rotate(-15deg);
    }
    
    .jar-body::after {
      content: '';
      position: absolute;
      bottom: 15%;
      right: 15%;
      width: 25%;
      height: 35%;
      background: radial-gradient(ellipse, 
        rgba(0, 0, 0, 0.15) 0%, 
        transparent 70%);
      border-radius: 50%;
      filter: blur(20px);
    }
    
    .jar-lid {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 70px;
      background: linear-gradient(180deg, 
        rgba(140, 190, 230, 0.9) 0%, 
        rgba(120, 170, 220, 0.95) 50%,
        rgba(100, 150, 200, 0.9) 100%);
      border: 8px solid rgba(160, 200, 240, 0.7);
      border-radius: 50%;
      box-shadow: 
        0 10px 30px rgba(0, 0, 0, 0.5),
        inset 0 -8px 20px rgba(0, 0, 0, 0.3),
        inset 0 8px 20px rgba(255, 255, 255, 0.4);
      transform-style: preserve-3d;
    }
    
    .jar-lid::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 50px;
      height: 25px;
      background: linear-gradient(180deg, 
        rgba(160, 200, 240, 1) 0%, 
        rgba(140, 180, 220, 1) 50%,
        rgba(120, 160, 200, 1) 100%);
      border-radius: 50%;
      box-shadow: 
        0 5px 15px rgba(0, 0, 0, 0.5),
        inset 0 3px 8px rgba(255, 255, 255, 0.6),
        inset 0 -2px 5px rgba(0, 0, 0, 0.2);
    }
    
    .coins-container {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 100%;
      display: block;
      perspective: 1200px;
      transform-style: preserve-3d;
      overflow: hidden;
      border-radius: 50%;
      clip-path: circle(50% at 50% 50%);
      pointer-events: none;
    }
    
    .coins-container.shaking {
      animation: jarShakeRotate 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) infinite;
    }
    
    @keyframes jarShakeRotate {
      0% { 
        transform: translateX(-50%) translateY(0) rotateZ(0deg); 
      }
      10% { 
        transform: translateX(-50%) translateY(-2px) rotateZ(-8deg); 
      }
      20% { 
        transform: translateX(-50%) translateY(2px) rotateZ(8deg); 
      }
      30% { 
        transform: translateX(-50%) translateY(-3px) rotateZ(-10deg); 
      }
      40% { 
        transform: translateX(-50%) translateY(1px) rotateZ(10deg); 
      }
      50% { 
        transform: translateX(-50%) translateY(-1px) rotateZ(-12deg); 
      }
      60% { 
        transform: translateX(-50%) translateY(3px) rotateZ(12deg); 
      }
      70% { 
        transform: translateX(-50%) translateY(-2px) rotateZ(-8deg); 
      }
      80% { 
        transform: translateX(-50%) translateY(2px) rotateZ(8deg); 
      }
      90% { 
        transform: translateX(-50%) translateY(-1px) rotateZ(-5deg); 
      }
      100% { 
        transform: translateX(-50%) translateY(0) rotateZ(0deg); 
      }
    }
    
    .coin {
      width: 45px;
      height: 45px;
      background: linear-gradient(135deg, 
        #FFD700 0%, 
        #FFA500 50%, 
        #FFD700 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 900;
      color: #8B4513;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
      box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.4),
        inset 0 -2px 4px rgba(139, 69, 19, 0.3);
      position: absolute;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      transform-style: preserve-3d;
      backface-visibility: visible;
    }
    
    .coin::before {
      content: '';
      position: absolute;
      top: 15%;
      left: 20%;
      width: 40%;
      height: 30%;
      background: radial-gradient(circle, 
        rgba(255, 255, 255, 0.6) 0%, 
        transparent 70%);
      border-radius: 50%;
      filter: blur(3px);
    }
    
    .coins-container.shaking .coin {
      animation: coinRealisticBounce 0.8s cubic-bezier(0.36, 0, 0.66, -0.56) infinite;
      animation-delay: var(--bounce-delay);
    }
    
    @keyframes coinRealisticBounce {
      0% {
        transform: translate(0, 0) rotateY(0deg) rotateZ(var(--random-rotation)) 
                   skewX(var(--random-skewX)) skewY(var(--random-skewY));
        filter: brightness(1);
      }
      /* Wide spread right - coins fly across jar */
      12% {
        transform: translate(calc(var(--horizontal-drift) * 3.0), calc(var(--bounce-height) * -2.8)) 
                   rotateY(120deg) rotateZ(calc(var(--random-rotation) + 40deg)) 
                   skewX(calc(var(--random-skewX) + 8deg)) skewY(calc(var(--random-skewY) - 7deg));
        filter: brightness(1.22);
      }
      /* Fall through center */
      20% {
        transform: translate(calc(var(--horizontal-drift) * 2.2), calc(var(--bounce-height) * -0.5)) 
                   rotateY(200deg) rotateZ(calc(var(--random-rotation) + 20deg)) 
                   skewX(calc(var(--random-skewX) + 4deg)) skewY(var(--random-skewY));
        filter: brightness(1.05);
      }
      /* Hit side and compress */
      30% {
        transform: translate(calc(var(--horizontal-drift) * 2.0), calc(var(--bounce-height) * 1.2)) 
                   rotateY(280deg) rotateZ(calc(var(--random-rotation) - 25deg)) 
                   skewX(calc(var(--random-skewX) - 5deg)) skewY(calc(var(--random-skewY) + 6deg)) 
                   scaleY(0.84);
        filter: brightness(0.86);
      }
      /* Wide spread left - coins fly to opposite side */
      45% {
        transform: translate(calc(var(--horizontal-drift) * -3.2), calc(var(--bounce-height) * -3.2)) 
                   rotateY(400deg) rotateZ(calc(var(--random-rotation) - 45deg)) 
                   skewX(calc(var(--random-skewX) - 9deg)) skewY(calc(var(--random-skewY) + 8deg));
        filter: brightness(1.28);
      }
      /* Descend through middle */
      55% {
        transform: translate(calc(var(--horizontal-drift) * -2.4), calc(var(--bounce-height) * -0.3)) 
                   rotateY(500deg) rotateZ(calc(var(--random-rotation) - 20deg)) 
                   skewX(calc(var(--random-skewX) - 4deg)) skewY(calc(var(--random-skewY) + 3deg));
        filter: brightness(1.0);
      }
      /* Bottom impact */
      65% {
        transform: translate(calc(var(--horizontal-drift) * -2.0), calc(var(--bounce-height) * 1.0)) 
                   rotateY(600deg) rotateZ(calc(var(--random-rotation) + 30deg)) 
                   skewX(calc(var(--random-skewX) + 7deg)) skewY(calc(var(--random-skewY) - 8deg)) 
                   scaleY(0.79);
        filter: brightness(0.82);
      }
      /* Medium bounce across */
      75% {
        transform: translate(calc(var(--horizontal-drift) * 1.8), calc(var(--bounce-height) * -2.0)) 
                   rotateY(700deg) rotateZ(calc(var(--random-rotation) + 25deg)) 
                   skewX(calc(var(--random-skewX) + 5deg)) skewY(calc(var(--random-skewY) - 5deg));
        filter: brightness(1.12);
      }
      /* Settle down gradually */
      85% {
        transform: translate(calc(var(--horizontal-drift) * -0.8), calc(var(--bounce-height) * 1.2)) 
                   rotateY(800deg) rotateZ(calc(var(--random-rotation) - 12deg)) 
                   skewX(calc(var(--random-skewX) - 2deg)) skewY(calc(var(--random-skewY) + 2deg)) 
                   scaleY(0.91);
        filter: brightness(0.92);
      }
      /* Final small bounce */
      93% {
        transform: translate(calc(var(--horizontal-drift) * 0.3), calc(var(--bounce-height) * 0.3)) 
                   rotateY(870deg) rotateZ(calc(var(--random-rotation) + 8deg)) 
                   skewX(var(--random-skewX)) skewY(var(--random-skewY));
        filter: brightness(1.04);
      }
      /* Rest at bottom - spread wider */
      100% {
        transform: translate(calc(var(--horizontal-drift) * 0.5), calc(var(--bounce-height) * 0.8)) rotateY(900deg) rotateZ(var(--random-rotation)) 
                   skewX(var(--random-skewX)) skewY(var(--random-skewY));
        filter: brightness(1);
      }
    }
    
    .coin.selected-highlight {
      animation: selectedPulse 0.5s ease-in-out 3;
      box-shadow: 
        0 0 20px rgba(255, 215, 0, 0.8),
        0 0 40px rgba(255, 215, 0, 0.6),
        0 4px 8px rgba(0, 0, 0, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.4),
        inset 0 -2px 4px rgba(139, 69, 19, 0.3);
    }
    
    @keyframes selectedPulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 
          0 0 20px rgba(255, 215, 0, 0.8),
          0 0 40px rgba(255, 215, 0, 0.6),
          0 4px 8px rgba(0, 0, 0, 0.3);
      }
      50% {
        transform: scale(1.3);
        box-shadow: 
          0 0 30px rgba(255, 215, 0, 1),
          0 0 60px rgba(255, 215, 0, 0.8),
          0 6px 12px rgba(0, 0, 0, 0.4);
      }
    }
    
    .selected-coin {
      width: 200px;
      height: 200px;
      background: linear-gradient(135deg, 
        #FFD700 0%, 
        #FFA500 30%,
        #FFD700 50%,
        #FFA500 70%,
        #FFD700 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 
        0 20px 60px rgba(255, 215, 0, 0.5),
        0 0 80px rgba(255, 215, 0, 0.3),
        inset 0 10px 30px rgba(255, 255, 255, 0.4),
        inset 0 -10px 30px rgba(139, 69, 19, 0.3);
      opacity: 0;
      transform: scale(0) rotate(0deg) translateY(-50px);
      transition: all 1s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative;
    }
    
    .selected-coin::before {
      content: '';
      position: absolute;
      top: 20%;
      left: 25%;
      width: 50%;
      height: 40%;
      background: radial-gradient(circle, 
        rgba(255, 255, 255, 0.6) 0%, 
        transparent 70%);
      border-radius: 50%;
      filter: blur(10px);
    }
    
    .selected-coin.reveal {
      opacity: 1;
      transform: scale(1) rotate(720deg) translateY(0);
      animation: coinSettleBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.4s forwards;
    }
    
    @keyframes coinSettleBounce {
      0% {
        transform: scale(1) rotate(720deg) translateY(0);
      }
      30% {
        transform: scale(1.08) rotate(720deg) translateY(-8px);
      }
      50% {
        transform: scale(0.98) rotate(720deg) translateY(4px);
      }
      70% {
        transform: scale(1.03) rotate(720deg) translateY(-3px);
      }
      85% {
        transform: scale(0.99) rotate(720deg) translateY(1px);
      }
      100% {
        transform: scale(1) rotate(720deg) translateY(0);
      }
    }
    
    .selected-coin.zoom {
      transform: scale(4) rotate(720deg);
      opacity: 0;
      transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .coin-jar-container.fade-out {
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.6s ease-out;
    }
    
    .coin-face {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      border: 8px solid rgba(139, 69, 19, 0.4);
    }
    
    .coin-number {
      font-size: 72px;
      font-weight: 900;
      color: #8B4513;
      text-shadow: 
        0 2px 4px rgba(255, 255, 255, 0.7),
        0 -2px 4px rgba(0, 0, 0, 0.3);
      animation: numberPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes numberPulse {
      0%, 100% { 
        transform: scale(1); 
        opacity: 1;
      }
      50% { 
        transform: scale(1.1); 
        opacity: 0.9;
      }
    }
    
    .selection-text {
      font-size: 32px;
      color: #FFD700;
      font-weight: 700;
      letter-spacing: 3px;
      text-transform: uppercase;
      text-shadow: 
        0 0 20px rgba(255, 215, 0, 0.8),
        0 0 40px rgba(255, 215, 0, 0.4);
      opacity: 0;
      animation: textFadeIn 0.8s ease-out 0.5s forwards;
    }
    
    @keyframes textFadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Auction Completion Button - Small bottom-right corner */
    .completion-prompt {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.9) 0%, rgba(56, 142, 60, 0.95) 100%);
      color: white;
      padding: 12px 20px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      z-index: 9998;
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      box-shadow: 0 4px 20px rgba(76, 175, 80, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    
    .completion-prompt.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
      animation: completionPulse 2s ease-in-out infinite;
    }
    
    @keyframes completionPulse {
      0%, 100% {
        box-shadow: 0 4px 20px rgba(76, 175, 80, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      50% {
        box-shadow: 0 6px 30px rgba(76, 175, 80, 0.6), 0 3px 12px rgba(0, 0, 0, 0.3);
      }
    }
    
    .completion-prompt:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(76, 175, 80, 0.5), 0 4px 12px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, rgba(76, 175, 80, 1) 0%, rgba(56, 142, 60, 1) 100%);
      animation: none;
    }
    
    .completion-prompt:active {
      transform: translateY(0);
      box-shadow: 0 2px 10px rgba(76, 175, 80, 0.4), 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    
    /* Next Random Prompt - bottom left for random mode */
    .next-random-prompt {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.95) 0%, rgba(25, 118, 210, 0.95) 100%);
      padding: 15px 25px;
      border-radius: 12px;
      color: white;
      font-size: 16px;
      font-weight: 700;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      z-index: 9998;
      border: 2px solid rgba(255, 255, 255, 0.3);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .next-random-prompt.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
      animation: nextRandomPulse 2s ease-in-out infinite;
    }
    
    @keyframes nextRandomPulse {
      0%, 100% {
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      }
      50% {
        box-shadow: 0 12px 48px rgba(33, 150, 243, 0.6);
      }
    }
    
    .next-random-prompt kbd {
      background: rgba(255, 255, 255, 0.3);
      padding: 5px 12px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 900;
      font-family: 'Courier New', monospace;
      border: 2px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    /* End Screen Overlay */
    .end-screen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.6s ease;
    }
    
    .end-screen-overlay.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .end-screen-image {
      max-width: 90%;
      max-height: 90vh;
      object-fit: contain;
      border-radius: 20px;
      box-shadow: 0 20px 80px rgba(0, 0, 0, 0.8);
      animation: endScreenZoom 1s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
    }
    
    @keyframes endScreenZoom {
      0% {
        opacity: 0;
        transform: scale(0.5) rotate(-5deg);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
    }

    /* Start Screen Overlay */
    .start-screen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      opacity: 1;
      pointer-events: all;
      transition: opacity 0.5s ease;
    }
    
    .start-screen-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .start-screen-content {
      text-align: center;
      animation: startScreenFadeIn 1s ease-out;
    }
    
    .start-screen-title {
      font-size: 72px;
      font-weight: 900;
      color: #ffffff;
      margin-bottom: 10px;
      text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      letter-spacing: 2px;
      animation: titlePulse 2s ease-in-out infinite;
    }
    
    .start-screen-subtitle {
      font-size: 28px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 50px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    .start-button {
      padding: 20px 60px;
      font-size: 24px;
      font-weight: 700;
      color: #ffffff;
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(76, 175, 80, 0.4);
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 15px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    .start-button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 15px 40px rgba(76, 175, 80, 0.6);
      background: linear-gradient(135deg, #45a049 0%, #4CAF50 100%);
    }
    
    .start-button:active {
      transform: translateY(-1px) scale(1.02);
    }
    
    .start-icon {
      font-size: 28px;
      animation: iconBounce 1.5s ease-in-out infinite;
    }
    
    .start-screen-hint {
      margin-top: 30px;
      font-size: 16px;
      color: rgba(255, 255, 255, 0.5);
      font-style: italic;
    }
    
    @keyframes startScreenFadeIn {
      0% {
        opacity: 0;
        transform: translateY(30px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes titlePulse {
      0%, 100% {
        text-shadow: 0 4px 20px rgba(76, 175, 80, 0.5);
      }
      50% {
        text-shadow: 0 4px 30px rgba(76, 175, 80, 0.8);
      }
    }
    
    @keyframes iconBounce {
      0%, 100% {
        transform: translateX(0);
      }
      50% {
        transform: translateX(5px);
      }
    }
    
    /* Reset Auction Button - Small and unobtrusive */
    .reset-auction-button {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 35px;
      height: 35px;
      padding: 0;
      font-size: 18px;
      color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .reset-auction-button:hover {
      color: rgba(255, 255, 255, 0.8);
      background: rgba(255, 87, 34, 0.2);
      border-color: rgba(255, 87, 34, 0.5);
      transform: rotate(180deg) scale(1.1);
    }

    /* Staggered animation for player cards */
    .player-card {
      animation: cardFadeIn 0.6s ease-out both;
    }

    .captain-card {
      animation: captainCardEntry 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55) both;
    }

    @keyframes cardFadeIn {
      from {
        opacity: 0;
        transform: translateY(30px) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes captainCardEntry {
      0% {
        opacity: 0;
        transform: translateY(50px) scale(0.8) rotateY(-10deg);
      }
      60% {
        transform: translateY(-10px) scale(1.05) rotateY(5deg);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1) rotateY(0deg);
      }
    }

    /* Stagger delay for cards */
    .players-grid .player-card:nth-child(1) { animation-delay: 0.1s; }
    .players-grid .player-card:nth-child(2) { animation-delay: 0.15s; }
    .players-grid .player-card:nth-child(3) { animation-delay: 0.2s; }
    .players-grid .player-card:nth-child(4) { animation-delay: 0.25s; }
    .players-grid .player-card:nth-child(5) { animation-delay: 0.3s; }
    .players-grid .player-card:nth-child(6) { animation-delay: 0.35s; }
    .players-grid .player-card:nth-child(7) { animation-delay: 0.4s; }
    .players-grid .player-card:nth-child(8) { animation-delay: 0.45s; }
    .players-grid .player-card:nth-child(9) { animation-delay: 0.5s; }
    .players-grid .player-card:nth-child(10) { animation-delay: 0.55s; }
    .players-grid .player-card:nth-child(11) { animation-delay: 0.6s; }
    .players-grid .player-card:nth-child(12) { animation-delay: 0.65s; }
    .players-grid .player-card:nth-child(n+13) { animation-delay: 0.7s; }
    
    /* Impact effect - Enhanced Apple style */
    .impact {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(220, 0, 0, 0.4) 0%, rgba(220, 0, 0, 0.2) 40%, rgba(220, 0, 0, 0) 70%);
      opacity: 0;
      z-index: 10001;
      box-shadow: 0 0 80px rgba(220, 0, 0, 0.5);
    }
    .impact.show {
      animation: impactWaveApple 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    }
    @keyframes impactWaveApple {
      0% {
        width: 200px;
        height: 200px;
        opacity: 1;
        box-shadow: 0 0 80px rgba(220, 0, 0, 0.6);
      }
      50% {
        width: 500px;
        height: 500px;
        opacity: 0.6;
        box-shadow: 0 0 120px rgba(220, 0, 0, 0.4);
      }
      100% {
        width: 800px;
        height: 800px;
        opacity: 0;
        box-shadow: 0 0 200px rgba(220, 0, 0, 0);
      }
    }
    
    /* Teams Info Overlay */
    .teams-info-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(10px);
      z-index: 20000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .teams-info-overlay.show {
      opacity: 1;
      visibility: visible;
    }
    
    .teams-info-container {
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      border-radius: 20px;
      padding: 40px;
      max-width: 1400px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8),
                  0 0 0 1px rgba(33, 150, 243, 0.3);
      transform: scale(0.9);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    
    .teams-info-overlay.show .teams-info-container {
      transform: scale(1);
      opacity: 1;
    }
    
    .teams-info-header {
      text-align: center;
      margin-bottom: 40px;
      border-bottom: 3px solid #2196F3;
      padding-bottom: 20px;
    }
    
    .teams-info-title {
      font-size: 48px;
      font-weight: 900;
      color: #2196F3;
      text-transform: uppercase;
      letter-spacing: 4px;
      margin: 0;
      text-shadow: 0 0 20px rgba(33, 150, 243, 0.5);
    }
    
    .teams-info-subtitle {
      font-size: 18px;
      color: #aaa;
      margin-top: 10px;
      letter-spacing: 2px;
    }
    
    .teams-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    
    .teams-table thead {
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
    }
    
    .teams-table th {
      padding: 20px 15px;
      text-align: left;
      font-size: 16px;
      font-weight: 700;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-bottom: 3px solid #1565C0;
    }
    
    .teams-table th:first-child {
      border-top-left-radius: 10px;
    }
    
    .teams-table th:last-child {
      border-top-right-radius: 10px;
    }
    
    .teams-table tbody tr {
      background: rgba(255, 255, 255, 0.03);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }
    
    .teams-table tbody tr:hover {
      background: rgba(33, 150, 243, 0.1);
      transform: translateX(5px);
    }
    
    .teams-table tbody tr:nth-child(even) {
      background: rgba(255, 255, 255, 0.05);
    }
    
    .teams-table tbody tr:nth-child(even):hover {
      background: rgba(33, 150, 243, 0.1);
    }
    
    .teams-table td {
      padding: 20px 15px;
      color: #fff;
      font-size: 18px;
    }
    
    .team-logo-cell {
      width: 80px;
      text-align: center;
    }
    
    .team-logo-small {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #2196F3;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    .team-name-cell {
      font-weight: 700;
      font-size: 22px;
      color: #2196F3;
      text-shadow: 0 0 10px rgba(33, 150, 243, 0.3);
    }
    
    .team-stat-value {
      font-weight: 600;
      color: #4CAF50;
    }
    
    .team-stat-value.warning {
      color: #ff9800;
    }
    
    .team-stat-value.danger {
      color: #f44336;
    }
    
    .team-captain {
      font-style: italic;
      color: #aaa;
    }
    
    .close-teams-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: rgba(244, 67, 54, 0.9);
      border: none;
      border-radius: 50%;
      color: #fff;
      font-size: 28px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
    }
    
    .close-teams-btn:hover {
      background: rgba(244, 67, 54, 1);
      transform: rotate(90deg) scale(1.1);
      box-shadow: 0 6px 20px rgba(244, 67, 54, 0.6);
    }
    
    .teams-info-footer {
      text-align: center;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: #888;
      font-size: 14px;
      letter-spacing: 1px;
    }
    
    /* Scrollbar styling for teams container */
    .teams-info-container::-webkit-scrollbar {
      width: 10px;
    }
    
    .teams-info-container::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
    }
    
    .teams-info-container::-webkit-scrollbar-thumb {
      background: #2196F3;
      border-radius: 10px;
    }
    
    .teams-info-container::-webkit-scrollbar-thumb:hover {
      background: #1976D2;
    }
    
    /* Team Slots View - Apple Inspired Design */
    .team-slots-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 30, 0.95) 100%);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      z-index: 25000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.4s;
    }

    /* Cricket animation loader */
    .team-slots-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 40px;
      z-index: 25001;
      width: 500px;
      height: 300px;
    }

    .cricket-animation-container {
      position: relative;
      width: 100%;
      height: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Cricket Bat */
    .cricket-bat {
      position: absolute;
      left: 30%;
      width: 80px;
      height: 120px;
      background: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #6B3410 100%);
      border-radius: 8px 8px 25px 25px;
      transform-origin: bottom center;
      animation: batSwing 1.2s ease-in-out infinite;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5),
                  inset 2px 2px 5px rgba(255, 255, 255, 0.2);
      z-index: 2;
    }

    .cricket-bat::before {
      content: '';
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      width: 18px;
      height: 35px;
      background: linear-gradient(180deg, #654321, #3e2914);
      border-radius: 3px;
    }

    .cricket-bat::after {
      content: '';
      position: absolute;
      top: 15%;
      left: 10%;
      right: 10%;
      height: 60%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.1) 20%, 
        transparent 40%,
        transparent 60%,
        rgba(255, 255, 255, 0.1) 80%, 
        transparent 100%);
      border-radius: 4px;
    }

    /* Cricket Ball */
    .cricket-ball {
      position: absolute;
      right: 30%;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle at 30% 30%, #DC143C, #8B0000);
      border-radius: 50%;
      animation: ballFly 1.2s ease-in-out infinite;
      box-shadow: 0 5px 25px rgba(220, 20, 60, 0.6),
                  inset -3px -3px 8px rgba(0, 0, 0, 0.4),
                  inset 3px 3px 8px rgba(255, 255, 255, 0.2);
      z-index: 1;
    }

    .cricket-ball::before {
      content: '';
      position: absolute;
      top: 48%;
      left: 0;
      right: 0;
      height: 2px;
      background: rgba(255, 255, 255, 0.4);
      box-shadow: 0 0 3px rgba(255, 255, 255, 0.6);
    }

    .cricket-ball::after {
      content: '';
      position: absolute;
      top: 48%;
      left: 0;
      right: 0;
      height: 2px;
      background: rgba(255, 255, 255, 0.4);
      transform: rotate(180deg);
      box-shadow: 0 0 3px rgba(255, 255, 255, 0.6);
    }

    /* Motion lines for speed effect */
    .motion-lines {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
      opacity: 0.6;
    }

    .motion-line {
      position: absolute;
      top: 50%;
      right: 35%;
      width: 60px;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
      animation: motionLine 1.2s ease-in-out infinite;
    }

    .motion-line:nth-child(2) {
      top: 45%;
      animation-delay: 0.1s;
    }

    .motion-line:nth-child(3) {
      top: 55%;
      animation-delay: 0.2s;
    }

    /* Animations */
    @keyframes batSwing {
      0%, 100% {
        transform: rotate(-15deg);
      }
      50% {
        transform: rotate(35deg);
      }
    }

    @keyframes ballFly {
      0% {
        transform: translateX(0) translateY(0) scale(1);
        opacity: 1;
      }
      50% {
        transform: translateX(-150px) translateY(-30px) scale(0.7);
        opacity: 0.8;
      }
      100% {
        transform: translateX(-300px) translateY(0) scale(0.5);
        opacity: 0;
      }
    }

    @keyframes motionLine {
      0% {
        transform: translateX(0) scaleX(1);
        opacity: 0;
      }
      50% {
        transform: translateX(-100px) scaleX(1.5);
        opacity: 1;
      }
      100% {
        transform: translateX(-200px) scaleX(0.5);
        opacity: 0;
      }
    }

    .team-slots-loading-text {
      color: rgba(255, 255, 255, 0.9);
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8),
                   0 0 20px rgba(33, 150, 243, 0.6);
      animation: textPulse 1.2s ease-in-out infinite;
    }

    @keyframes textPulse {
      0%, 100% {
        opacity: 0.7;
        transform: scale(1);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
    }
    
    /* Team color overlay background */
    .team-slots-overlay::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at top center, var(--team-color, rgba(33, 150, 243, 0.15)) 0%, transparent 70%),
                  radial-gradient(circle at 20% 80%, var(--team-color, rgba(33, 150, 243, 0.08)) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, var(--team-color-light, rgba(33, 150, 243, 0.08)) 0%, transparent 50%);
      opacity: 0.6;
      z-index: -1;
      animation: backgroundPulse 8s ease-in-out infinite;
    }

    @keyframes backgroundPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 0.8; }
    }
    
    .team-slots-overlay.show {
      opacity: 1;
      visibility: visible;
    }
    
    /* Custom scrollbar styling */
    .players-grid-wrapper::-webkit-scrollbar {
      width: 8px;
    }
    
    .players-grid-wrapper::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 4px;
    }
    
    .players-grid-wrapper::-webkit-scrollbar-thumb {
      background: var(--team-color, rgba(33, 150, 243, 0.4));
      border-radius: 4px;
      transition: background 0.3s ease;
    }
    
    .players-grid-wrapper::-webkit-scrollbar-thumb:hover {
      background: var(--team-color, rgba(33, 150, 243, 0.6));
    }
    
    .team-slots-container {
      width: 100%;
      max-width: 100vw;
      height: 100vh;
      margin: 0 auto;
      padding: 8px 15px;
      overflow: hidden;
      transform: translateY(20px);
      opacity: 0;
      transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s ease;
      display: grid;
      grid-template-columns: 250px 1fr;
      grid-template-rows: auto 1fr;
      gap: 10px;
      box-sizing: border-box;
    }
    
    /* Responsive design for smaller screens */
    @media (max-width: 1600px) {
      .team-slots-container {
        padding: 8px 12px;
        grid-template-columns: 220px 1fr;
        gap: 8px;
      }
    }
    
    @media (max-width: 1200px) {
      .team-slots-container {
        padding: 6px 10px;
        grid-template-columns: 200px 1fr;
        gap: 8px;
      }
    }
    
    @media (max-width: 768px) {
      .team-slots-container {
        padding: 6px 8px;
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr;
        gap: 6px;
      }
    }
    
    .team-slots-overlay.show .team-slots-container {
      transform: translateY(0);
      opacity: 1;
    }
    
    /* Team Header Section */
    .team-slots-header {
      grid-column: 1 / -1;
      text-align: center;
      margin-bottom: 0;
      animation: fadeInDown 0.6s ease-out 0.2s both;
    }
    
    @media (max-width: 768px) {
      .team-slots-header {
        margin-bottom: 0;
      }
    }
    
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .team-logo-large {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      margin: 0 auto 4px;
      border: 2px solid var(--team-color-border, rgba(255, 255, 255, 0.15));
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5),
                  0 0 40px var(--team-color-glow, rgba(33, 150, 243, 0.3)),
                  inset 0 0 0 1px rgba(255, 255, 255, 0.1);
      object-fit: cover;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }
    
    .team-logo-large::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      background: conic-gradient(from 0deg, 
                  var(--team-color, rgba(33, 150, 243, 0.4)) 0%, 
                  transparent 25%, 
                  var(--team-color-light, rgba(33, 150, 243, 0.2)) 50%, 
                  transparent 75%, 
                  var(--team-color, rgba(33, 150, 243, 0.4)) 100%);
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: -1;
      animation: rotate 8s linear infinite;
    }
    
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .team-logo-large:hover {
      transform: scale(1.08);
      border-color: var(--team-color, rgba(33, 150, 243, 0.6));
    }
    
    .team-logo-large:hover::after {
      opacity: 1;
    }
    
    @media (max-width: 768px) {
      .team-logo-large {
        width: 60px;
        height: 60px;
        margin-bottom: 8px;
      }
    }
    
    .team-slots-title {
      font-size: 30px;
      font-weight: 900;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin: 0 0 4px 0;
      text-shadow: 0 4px 30px rgba(0, 0, 0, 0.6),
                   0 0 40px var(--team-color-glow, rgba(33, 150, 243, 0.4));
      background: linear-gradient(135deg, 
                  #fff 0%, 
                  var(--team-color, #2196F3) 50%,
                  var(--team-color-light, #00BCD4) 100%);
      background-clip: text;
      animation: shimmer 3s ease-in-out infinite;
    }
    
    @keyframes shimmer {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.9; }
    }
    
    @media (max-width: 1200px) {
      .team-slots-title {
        font-size: 18px;
        letter-spacing: 1.2px;
      }
    }
    
    @media (max-width: 768px) {
      .team-slots-title {
        font-size: 15px;
        letter-spacing: 1px;
        margin-bottom: 3px;
      }
    }
    
    .team-stats-summary {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 3px;
      flex-wrap: wrap;
    }
    
    .team-stat-item {
      text-align: center;
      padding: 4px 10px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--team-color-border, rgba(255, 255, 255, 0.1));
      border-radius: 6px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      min-width: 70px;
    }
    
    .team-stat-item:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: var(--team-color, rgba(33, 150, 243, 0.4));
      transform: translateY(-2px);
      box-shadow: 0 8px 20px var(--team-color-glow, rgba(33, 150, 243, 0.2));
    }
    
    .team-stat-label {
      font-size: 18px;
      color: rgba(255, 215, 0, 1.0);
      text-transform: uppercase;
      letter-spacing: 0.6px;
      margin-bottom: 2px;
      font-weight: 600;
    }
    
    .team-stat-number {
      font-size: 18px;
      font-weight: 800;
      color:  rgba(255, 255, 255, 1.0);
      text-shadow: 0 0 20px var(--team-color-glow, rgba(33, 150, 243, 1.0));
      letter-spacing: 0.3px;
    }
    
    @media (max-width: 768px) {
      .team-stats-summary {
        gap: 10px;
        margin-top: 3px;
      }
      
      .team-stat-item {
        padding: 4px 10px;
        min-width: 75px;
      }
      
      .team-stat-number {
        font-size: 12px;
      }
    }
    
    /* Captain Card Container - Left Side */
    .captain-card-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 10px;
      overflow: hidden;
    }
    
    @media (max-width: 768px) {
      .captain-card-container {
        grid-column: 1;
        padding: 6px;
      }
    }
    
    /* Players Grid Wrapper - Right Side */
    .players-grid-wrapper {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 5px;
      min-height: 0;
    }
    
    @media (max-width: 768px) {
      .players-grid-wrapper {
        grid-column: 1;
      }
    }
    
    /* Players Grid */
    .players-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
      max-width: 100%;
      width: 100%;
      margin: 0 auto;
      animation: fadeInUp 0.6s ease-out 0.4s both;
      align-content: start;
      justify-content: center;
      padding: 0;
      grid-auto-flow: dense; /* Allow items to fill gaps efficiently */
    }
    
    /* Grid variations for different player counts */
    .players-grid.grid-4-cols {
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }
    
    .players-grid.grid-6-cols {
      grid-template-columns: repeat(6, 1fr);
      gap: 12px;
    }
    
    /* Responsive grid layout */
    @media (max-width: 1600px) {
      .players-grid {
        gap: 10px;
      }
      .players-grid.grid-6-cols {
        grid-template-columns: repeat(6, 1fr);
        gap: 10px;
      }
      .players-grid.grid-4-cols {
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
      }
    }
    
    @media (max-width: 1200px) {
      .players-grid {
        gap: 10px;
      }
      .players-grid.grid-6-cols {
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
      }
      .players-grid.grid-4-cols {
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }
    }
    
    @media (max-width: 900px) {
      .players-grid {
        gap: 8px;
      }
      .players-grid.grid-6-cols {
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }
      .players-grid.grid-4-cols {
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }
    }
    
    @media (max-width: 600px) {
      .players-grid {
        gap: 6px;
      }
      .players-grid.grid-6-cols,
      .players-grid.grid-4-cols {
        grid-template-columns: repeat(2, 1fr);
        gap: 6px;
      }
    }
    
    /* Captain Card - Standalone Left Side Card */
    .captain-card {
      width: 100%;
      max-width: 230px;
      aspect-ratio: 3/4;
      background: linear-gradient(145deg, 
                  rgba(255, 215, 0, 0.15) 0%, 
                  rgba(20, 20, 30, 0.98) 50%);
      border: 2px solid rgba(255, 215, 0, 0.4);
      border-radius: 20px;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-shadow: 0 15px 45px rgba(255, 215, 0, 0.3),
                  0 0 30px rgba(255, 215, 0, 0.2),
                  0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      backdrop-filter: blur(15px);
      transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      animation: captainGlow 3s ease-in-out infinite;
      margin: 0 auto;
    }

    /* Shine effect on captain card */
    .captain-card::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, 
                  transparent 30%, 
                  rgba(255, 255, 255, 0.1) 50%, 
                  transparent 70%);
      animation: shine 4s ease-in-out infinite;
      z-index: 1;
      pointer-events: none;
    }

    @keyframes shine {
      0%, 100% {
        transform: translateX(-100%) translateY(-100%) rotate(45deg);
      }
      50% {
        transform: translateX(100%) translateY(100%) rotate(45deg);
      }
    }

    @keyframes captainGlow {
      0%, 100% { 
        box-shadow: 0 15px 45px rgba(255, 215, 0, 0.3),
                    0 0 30px rgba(255, 215, 0, 0.2),
                    0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      }
      50% { 
        box-shadow: 0 15px 45px rgba(255, 215, 0, 0.5),
                    0 0 40px rgba(255, 215, 0, 0.4),
                    0 0 0 1px rgba(255, 215, 0, 0.3) inset;
      }
    }

    .captain-card:hover {
      transform: translateY(-5px) scale(1.02);
      border-color: rgba(255, 215, 0, 0.7);
    }

    .captain-card .player-card-image-container {
      height: 70%;
      border-radius: 25px 25px 0 0;
      z-index: 2;
    }

    .captain-card .player-card-name {
      font-size: 24px;
      letter-spacing: 1px;
      color: #FFF;
      padding-top: 10px;
      z-index: 2;
    }

    .captain-card .player-card-role {
      font-size: 20px;
      color: rgba(255, 215, 0, 0.9);
      border-color: rgba(255, 215, 0, 0.3);
      z-index: 2;
      padding: 3px 8px;
      margin-bottom: 10px;
    }

    .captain-card .player-card-info {
      z-index: 2;
    }

    .captain-card .player-captain-badge {
      width: 35px;
      height: 35px;
      font-size: 20px;
      background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
      border: 2px solid rgba(255, 255, 255, 0.9);
      box-shadow: 0 6px 25px rgba(255, 215, 0, 0.6);
      animation: captainBadgePulse 2s ease-in-out infinite;
      z-index: 3;
    }

    @keyframes captainBadgePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .captain-card .player-role-icon {
      width: 32px;
      height: 32px;
      font-size: 18px;
      border: 2px solid rgba(255, 215, 0, 0.5);
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }

    @media (max-width: 1600px) {
      .captain-card {
        max-width: 200px;
      }
    }

    @media (max-width: 1200px) {
      .captain-card {
        max-width: 180px;
      }
      
      .captain-card .player-card-name {
        font-size: 12px;
      }

      .captain-card .player-captain-badge {
        width: 32px;
        height: 32px;
        font-size: 18px;
      }

      .captain-card .player-role-icon {
        width: 28px;
        height: 28px;
        font-size: 16px;
      }
    }

    @media (max-width: 768px) {
      .captain-card {
        max-width: 100%;
        width: 200px;
      }

      .captain-card .player-card-name {
        font-size: 11px;
        letter-spacing: 0.8px;
      }

      .captain-card .player-card-role {
        font-size: 8px;
      }

      .captain-card .player-captain-badge {
        width: 28px;
        height: 28px;
        font-size: 16px;
      }

      .captain-card .player-role-icon {
        width: 24px;
        height: 24px;
        font-size: 14px;
      }

      .player-stats-tooltip {
        min-width: 200px;
        padding: 12px;
      }

      .stats-tooltip-title {
        font-size: 12px;
        margin-bottom: 10px;
      }

      .stats-tooltip-item {
        padding: 6px 8px;
      }

      .stats-tooltip-label {
        font-size: 10px;
      }

      .stats-tooltip-value {
        font-size: 12px;
      }
    }

    /* Player Card - Modern Card Holder Design */
    .player-card {
      background: linear-gradient(145deg, 
                  rgba(20, 20, 30, 0.95) 0%, 
                  rgba(10, 10, 20, 0.98) 100%);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 20px;
      padding: 0;
      text-align: center;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6),
                  0 0 0 1px rgba(255, 255, 255, 0.05) inset,
                  0 2px 20px -5px var(--team-color-glow, rgba(33, 150, 243, 0.2));
      width: 100%;
      height: 83%;
      aspect-ratio: 3/4;
      transform-style: preserve-3d;
      perspective: 1000px;
      backdrop-filter: blur(10px);
    }
    
    @media (max-width: 768px) {
      .player-card {
        border-radius: 16px;
      }
      
      .player-card-image-container {
        border-radius: 16px 16px 0 0;
      }
      
      .player-card::after {
        border-radius: 16px 16px 0 0;
      }
    }
    
    /* Player Card Image Container - Top Section */
    .player-card-image-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 65%;
      overflow: hidden;
      border-radius: 20px 20px 0 0;
      z-index: 0;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    }
    
    .player-card-image-container::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.15) 100%);
      z-index: 1;
      pointer-events: none;
      transition: background 0.5s ease;
    }

    .player-card:hover .player-card-image-container::before {
      background: radial-gradient(ellipse at center, 
                  var(--team-color, rgba(33, 150, 243, 0.1)) 0%, 
                  rgba(0, 0, 0, 0.25) 100%);
    }
    
    .player-card-image {
      width: 100%;
      height: 160%;
      object-fit: cover;
      object-position: center 15%;
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      display: block;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      filter: brightness(0.95) contrast(1.05);
    }

    .player-card:hover .player-card-image {
      filter: brightness(1.05) contrast(1.1) saturate(1.2);
    }
    
    /* Subtle overlay for better contrast */
    .player-card::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 65%;
      background: linear-gradient(to bottom, 
                  rgba(0, 0, 0, 0.05) 0%,
                  rgba(0, 0, 0, 0.1) 40%,
                  rgba(0, 0, 0, 0.25) 100%);
      z-index: 1;
      pointer-events: none;
      transition: all 0.5s ease;
      border-radius: 20px 20px 0 0;
    }
    
    .player-card:hover {
      border-color: var(--team-color, rgba(33, 150, 243, 0.5));
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8),
                  0 0 0 1px var(--team-color, rgba(33, 150, 243, 0.3)) inset,
                  0 5px 40px var(--team-color-glow, rgba(33, 150, 243, 0.4));
      transform: translateY(-8px);
    }
    
    .player-card:hover .player-card-image {
      transform: scale(1.08);
      object-position: center center;
    }
    
    .player-card:hover::after {
      background: linear-gradient(to bottom, 
                  rgba(0, 0, 0, 0.1) 0%,
                  rgba(0, 0, 0, 0.15) 40%,
                  rgba(0, 0, 0, 0.3) 100%);
    }

    /* Captain Stats Tooltip - Larger */
    .captain-card .player-stats-tooltip {
      position: absolute;
      top: 70%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 15px;
      padding: 20px;
      z-index: 2;
      opacity: 0;
      pointer-events: none;
      background-color: rgba(0, 0, 0, 0.5);
      transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(12px);
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.9),
                  0 0 60px var(--team-color-glow, rgba(33, 150, 243, 0.4));
      min-width: 200px;
      max-width: 340px;
    }

    .captain-card:hover .player-stats-tooltip {
      opacity: 1;
      pointer-events: auto;
      animation: tooltipBounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    /* Regular Player Stats Tooltip - Smaller */
    .player-card:not(.captain-card) .player-stats-tooltip {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 12px;
      padding: 12px 14px;
      z-index: 2;
      opacity: 0;
      pointer-events: none;
      background-color: rgba(0, 0, 0, 0.45);
      transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 35px rgba(0, 0, 0, 0.8),
                  0 0 40px var(--team-color-glow, rgba(33, 150, 243, 0.3));
      min-width: 140px;
      max-width: 220px;
    }

    .player-card:not(.captain-card):hover .player-stats-tooltip {
      opacity: 1;
      pointer-events: auto;
      animation: tooltipBounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    @keyframes tooltipBounce {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      70% {
        transform: translate(-50%, -50%) scale(1.05);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Captain Stats Tooltip Title */
    .captain-card .stats-tooltip-title {
      font-size: 16px;
      font-weight: 800;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 15px;
      text-align: center;
      text-shadow: 0 0 20px var(--team-color-glow, rgba(33, 150, 243, 0.6));
    }

    /* Regular Player Stats Tooltip Title - Smaller */
    .player-card:not(.captain-card) .stats-tooltip-title {
      font-size: 12px;
      font-weight: 700;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 10px;
      text-align: center;
      text-shadow: 0 0 15px var(--team-color-glow, rgba(33, 150, 243, 0.5));
    }

    /* Captain Stats Tooltip Grid */
    .captain-card .stats-tooltip-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    /* Regular Player Stats Tooltip Grid - Compact */
    .player-card:not(.captain-card) .stats-tooltip-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }

    /* Captain Stats Tooltip Item */
    .captain-card .stats-tooltip-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    /* Regular Player Stats Tooltip Item - Smaller */
    .player-card:not(.captain-card) .stats-tooltip-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 8px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .stats-tooltip-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 3px;
      background: var(--team-color, #2196F3);
      transform: scaleY(0);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .stats-tooltip-item:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: var(--team-color, rgba(33, 150, 243, 0.3));
      transform: translateX(4px);
      box-shadow: 0 4px 15px var(--team-color-glow, rgba(33, 150, 243, 0.2));
    }

    .stats-tooltip-item:hover::before {
      transform: scaleY(1);
    }

    /* Captain Stats Tooltip Label */
    .captain-card .stats-tooltip-label {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
    }

    /* Regular Player Stats Tooltip Label - Smaller */
    .player-card:not(.captain-card) .stats-tooltip-label {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.65);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-weight: 600;
    }

    /* Captain Stats Tooltip Value */
    .captain-card .stats-tooltip-value {
      font-size: 14px;
      font-weight: 800;
      color: #fff;
      text-shadow: 0 0 10px var(--team-color-glow, rgba(33, 150, 243, 0.4));
    }

    /* Regular Player Stats Tooltip Value - Smaller */
    .player-card:not(.captain-card) .stats-tooltip-value {
      font-size: 11px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 8px var(--team-color-glow, rgba(33, 150, 243, 0.3));
    }
    
    /* TBD Card - Modern Empty Slot Design */
    .player-card.tbd {
      background: linear-gradient(145deg, 
                  rgba(30, 30, 40, 0.6) 0%, 
                  rgba(20, 20, 30, 0.7) 100%);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-style: dashed;
      border-color: rgba(255, 255, 255, 0.12);
      border-width: 2px;
      height: 260px;
      width: 220px;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .player-card.tbd .player-card-image-container {
      display: none;
    }
    
    .player-card.tbd::after {
      display: none;
    }
    
    .player-card.tbd:hover {
      transform: translateY(-6px);
      border-color: var(--team-color, rgba(33, 150, 243, 0.3));
      background: linear-gradient(145deg, 
                  rgba(35, 35, 45, 0.7) 0%, 
                  rgba(25, 25, 35, 0.8) 100%);
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5),
                  0 0 30px var(--team-color-glow, rgba(33, 150, 243, 0.2));
    }
    
    /* Player Avatar - Hidden for sold players (image is in background) */
    .player-avatar {
      display: none;
    }
    
    /* TBD Avatar - Visible only for TBD cards */
    .player-avatar-tbd {
      width: 100%;
      max-width: 140px;
      aspect-ratio: 1/1;
      border-radius: 50%;
      margin: 20px auto 20px;
      border: 3px dashed rgba(255, 255, 255, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.03);
      opacity: 0.35;
      overflow: hidden;
      flex-shrink: 0;
      transition: all 0.4s ease;
    }
    
    .player-avatar-tbd img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;
      filter: grayscale(100%) brightness(0.7);
      transition: all 0.4s ease;
    }
    
    .player-card.tbd:hover .player-avatar-tbd {
      opacity: 0.5;
      border-color: var(--team-color, rgba(33, 150, 243, 0.3));
      transform: scale(1.05);
    }
    
    .player-card.tbd:hover .player-avatar-tbd img {
      filter: grayscale(80%) brightness(0.8);
    }
    
    @media (max-width: 768px) {
      .player-avatar-tbd {
        max-width: 70px;
        margin-bottom: 12px;
        border-width: 2px;
      }
    }
    
    /* Player Info Container - Dark Background Section */
    .player-card-info {
      position: relative;
      width: 100%;
      display: flex;
      flex-direction: column;
      top: 55%;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.05);
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      gap: 6px;
    }
    
    .player-card:hover {
      padding-top: 20px;
      gap: 8px;
    }
    
    .player-card:hover .player-card-info{
      background: rgba(255, 255, 255, 0.08);
      /* border-top-color: var(--team-color, rgba(33, 150, 243, 0.3)); */
      padding-top: 20px;
      padding-bottom: 20px;
      gap: 8px;
    }

    /* Player Name - Dark background */
    .player-card-name {
      font-size: 13px;
      font-weight: 900;
      color: #fff;
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 1px;
      line-height: 1.3;
      text-align: center;
      width: 100%;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 2;
      position: relative;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    .player-card:hover .player-card-name {
      letter-spacing: 1.2px;
      color: var(--team-color, #2196F3);
      text-shadow: 0 2px 15px var(--team-color-glow, rgba(33, 150, 243, 0.6)),
                   0 0 30px var(--team-color-glow, rgba(33, 150, 243, 0.4));
    }
    
    .player-card-role {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.7);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      text-align: center;
      z-index: 2;
      position: relative;
      transition: all 0.4s ease;
      padding: 2px 8px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .player-card:hover .player-card-role {
      color: rgba(255, 255, 255, 0.9);
      border-color: var(--team-color, rgba(33, 150, 243, 0.3));
    }
    
    /* Price Badge - Bottom Left in Dark Section */
    .player-card-price {
      position: absolute;
      bottom: 16px;
      left: 14px;
      padding: 6px 12px 6px 10px;
      background: var(--team-color, rgba(33, 150, 243, 0.15));
      border: 1px solid var(--team-color, rgba(33, 150, 243, 0.3));
      border-radius: 8px;
      font-size: 14px;
      font-weight: 800;
      color: var(--team-color, #2196F3);
      letter-spacing: 0.8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 3;
      white-space: nowrap;
      backdrop-filter: blur(10px);
    }
    
    .player-card:hover .player-card-price {
      background: var(--team-color, rgba(33, 150, 243, 0.25));
      border-color: var(--team-color, rgba(33, 150, 243, 0.6));
      color: #fff;
      box-shadow: 0 4px 20px var(--team-color-glow, rgba(33, 150, 243, 0.4)),
                  0 0 30px var(--team-color-glow, rgba(33, 150, 243, 0.3));
      transform: scale(1.05);
    }
    
    /* Role Icon - Bottom Right in Dark Section */
    .player-role-icon {
      position: absolute;
      bottom: 16px;
      right: 14px;
      width: 34px;
      height: 34px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 3;
      backdrop-filter: blur(10px);
    }
    
    .player-card:hover .player-role-icon {
      background: var(--team-color, rgba(33, 150, 243, 0.2));
      border-color: var(--team-color, rgba(33, 150, 243, 0.5));
      box-shadow: 0 4px 20px var(--team-color-glow, rgba(33, 150, 243, 0.4)),
                  0 0 30px var(--team-color-glow, rgba(33, 150, 243, 0.3));
      transform: rotate(15deg) scale(1.1);
    }
    
    /* Captain Badge - Top Right on Image */
    .player-captain-badge {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 38px;
      height: 38px;
      background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
      border: 2px solid rgba(255, 255, 255, 0.95);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 900;
      color: #000;
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.6),
                  0 0 30px rgba(255, 215, 0, 0.4),
                  0 0 0 3px rgba(0, 0, 0, 0.3);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 3;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .player-card:hover .player-captain-badge {
      box-shadow: 0 6px 30px rgba(255, 215, 0, 0.9),
                  0 0 50px rgba(255, 215, 0, 0.7),
                  0 0 0 4px rgba(0, 0, 0, 0.4);
      transform: rotate(360deg) scale(1.15);
    }
    
    @media (max-width: 768px) {
      .player-card-info {
        padding: 14px 10px 12px;
        gap: 4px;
      }
      
      .player-card-name {
        font-size: 11px;
        letter-spacing: 0.6px;
      }
      
      .player-card-role {
        font-size: 9px;
        padding: 2px 6px;
      }
      
      .player-card-price {
        padding: 5px 10px 5px 8px;
        font-size: 12px;
        bottom: 12px;
        left: 10px;
      }
      
      .player-role-icon {
        width: 28px;
        height: 28px;
        font-size: 15px;
        bottom: 12px;
        right: 10px;
      }
      
      .player-captain-badge {
        width: 32px;
        height: 32px;
        font-size: 17px;
        top: 10px;
        right: 10px;
      }
    }
    
    /* TBD Card Specific Styling */
    .player-card.tbd .player-card-info {
      height: auto;
      background: transparent;
      border-top: none;
      padding: 0;
      gap: 0;
    }
    
    .player-card.tbd .player-card-name {
      position: relative;
      z-index: 1;
      text-shadow: none;
      font-size: 13px;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.4);
      font-weight: 700;
      margin: 0;
    }
    
    .player-card.tbd:hover .player-card-name {
      color: rgba(255, 255, 255, 0.6);
      letter-spacing: 2px;
    }
    
    .player-card-tbd-text {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.25);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: auto;
      padding-top: 8px;
      position: relative;
      z-index: 1;
      text-align: center;
    }
    
    @media (max-width: 768px) {
      .player-card-tbd-text {
        font-size: 10px;
        padding-top: 6px;
      }
    }
    
    /* Close Button */
    .close-team-slots-btn {
      position: fixed;
      top: 30px;
      right: 30px;
      width: 56px;
      height: 56px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      color: #fff;
      font-size: 28px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 25001;
    }
    
    .close-team-slots-btn:hover {
      background: rgba(244, 67, 54, 0.9);
      border-color: rgba(244, 67, 54, 1);
      transform: rotate(90deg) scale(1.1);
      box-shadow: 0 8px 25px rgba(244, 67, 54, 0.4);
    }
    
    /* Team Selection Menu */
    .team-selection-menu {
      position: fixed;
      top: 30px;
      left: 30px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 15px;
      z-index: 25001;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: 200px;
    }
    
    .team-selection-menu.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    .team-selection-menu-title {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 10px;
      font-weight: 600;
    }
    
    .team-menu-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 5px;
    }
    
    .team-menu-item:hover {
      background: rgba(33, 150, 243, 0.2);
    }
    
    .team-menu-number {
      width: 28px;
      height: 28px;
      background: rgba(33, 150, 243, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      color: #2196F3;
    }
    
    .team-menu-name {
      font-size: 15px;
      color: #fff;
      font-weight: 600;
    }
    
    /* Section Title */
    .section-title {
      font-size: 16px;
      color: rgba(255, 255, 255, 0.6);
      text-transform: uppercase;
      letter-spacing: 2px;
      margin: 20px 0 15px 0;
      text-align: center;
      font-weight: 700;
    }
    
    /* Hotkey Helper Button */
    .hotkey-helper-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 500;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
      border: 3px solid rgba(33, 150, 243, 0.5);
      color: white;
      font-size: 24px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .hotkey-helper-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6);
    }
    
    /* Hotkey Helper Overlay */
    .hotkey-helper-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(10px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .hotkey-helper-overlay.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .hotkey-helper-content {
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      border: 3px solid #2196F3;
      border-radius: 20px;
      padding: 40px;
      max-width: 900px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(33, 150, 243, 0.3);
      position: relative;
    }
    
    .close-hotkey-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(244, 67, 54, 0.2);
      border: 2px solid #f44336;
      color: #f44336;
      font-size: 28px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      line-height: 1;
    }
    
    .close-hotkey-btn:hover {
      background: #f44336;
      color: white;
      transform: rotate(90deg);
    }
    
    .hotkey-helper-title {
      font-size: 36px;
      color: #2196F3;
      text-align: center;
      margin-bottom: 30px;
      font-weight: 900;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .hotkey-section {
      margin-bottom: 30px;
    }
    
    .hotkey-section-title {
      font-size: 22px;
      color: #2196F3;
      margin-bottom: 15px;
      font-weight: 700;
      border-bottom: 2px solid rgba(33, 150, 243, 0.3);
      padding-bottom: 10px;
    }
    
    .hotkey-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 15px;
    }
    
    .hotkey-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 12px 15px;
      background: rgba(33, 150, 243, 0.05);
      border-radius: 10px;
      border-left: 3px solid #2196F3;
      transition: all 0.2s ease;
    }
    
    .hotkey-item:hover {
      background: rgba(33, 150, 243, 0.15);
      transform: translateX(5px);
    }
    
    .hotkey-item kbd {
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 700;
      font-family: 'Courier New', monospace;
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
      min-width: 40px;
      text-align: center;
      white-space: nowrap;
    }
    
    .hotkey-item span {
      color: #ddd;
      font-size: 16px;
      flex: 1;
    }
    
    /* Bid Team Warning */
    .bid-team-warning {
      margin-top: 6px;
      padding: 5px 8px;
      background: linear-gradient(135deg, rgba(255, 152, 0, 0.15) 0%, rgba(245, 124, 0, 0.15) 100%);
      border: 2px solid rgba(255, 152, 0, 0.6);
      border-radius: 6px;
      font-size: 10px;
      font-weight: 600;
      color: #ff9800;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      animation: warningPulse 2s ease-in-out infinite;
    }
    
    .warning-icon {
      font-size: 12px;
      animation: warningShake 0.5s ease-in-out infinite;
    }
    
    .warning-text {
      font-size: 10px;
      line-height: 1.3;
    }
    
    @keyframes warningPulse {
      0%, 100% {
        box-shadow: 0 0 5px rgba(255, 152, 0, 0.3);
        border-color: rgba(255, 152, 0, 0.6);
      }
      50% {
        box-shadow: 0 0 12px rgba(255, 152, 0, 0.5);
        border-color: rgba(255, 152, 0, 0.8);
      }
    }
    
    @keyframes warningShake {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-10deg); }
      75% { transform: rotate(10deg); }
    }
    
    /* Bid Confirm Hint (inline in bid display) */
    .bid-confirm-hint {
      margin-top: 10px;
      padding: 8px 12px;
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.2) 0%, rgba(56, 142, 60, 0.2) 100%);
      border: 2px solid #4CAF50;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 700;
      color: #4CAF50;
      text-align: center;
      animation: hintPulse 1.5s ease-in-out infinite;
    }
    
    .bid-confirm-hint kbd {
      background: #4CAF50;
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 900;
      font-family: 'Courier New', monospace;
      margin: 0 2px;
    }
    
    @keyframes hintPulse {
      0%, 100% {
        box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
      }
      50% {
        box-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
      }
    }
    
    .bid-display.confirm-mode {
      border-color: #4CAF50;
      box-shadow: 0 10px 40px rgba(76, 175, 80, 0.4),
                  0 0 0 8px rgba(76, 175, 80, 0.1);
    }
    
    .bid-display.confirm-mode .bid-amount {
      color: #4CAF50;
      text-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
    }
    
    .players-grid-wrapper {
      flex: 1;
      overflow-y: none;
    }
    
    .players-grid-wrapper::-webkit-scrollbar {
      width: 6px;
    }
    
    .players-grid-wrapper::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
    }
    
    .players-grid-wrapper::-webkit-scrollbar-thumb {
      background: rgba(33, 150, 243, 0.5);
      border-radius: 10px;
    }
    
    .players-grid-wrapper::-webkit-scrollbar-thumb:hover {
      background: rgba(33, 150, 243, 0.7);
    }
  </style>

  <style>
    /* Undo Button Styles */
    .undo-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.7);
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 1000;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    .undo-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.9);
      transform: scale(1.1);
    }
    
    .undo-button:active {
      transform: scale(0.95);
    }
    
    .undo-button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none;
    }
  </style>
</head>
<body>

  <div class="card-wrapper">
    <div class="card" id="card">
      <!-- Player ID Badge -->
      <div class="player-id-badge" id="playerId">001</div>
    
    <!-- Profile Container with Circular Image and Info -->
    <div class="profile-container">
      <!-- Circular Profile Image -->
      <div class="profile-circle">
        <img id="profileImg" 
             src="https://ui-avatars.com/api/?name=Player&size=450&background=2d5f3f&color=ffffff&bold=true&font-size=0.4" 
             alt="Player Profile"
             loading="eager"
             decoding="async"
             fetchpriority="high"/>
      </div>
      
      <!-- Player Info -->
      <div class="player-info-section">
        <div class="info-grid">
          <div class="info-item">
            <div class="info-label">Name</div>
            <div class="info-value player-name" id="playerName">PLAYER NAME</div>
          </div>
          
          <div class="info-item">
            <div class="info-label">Role</div>
            <div class="info-value role-value" id="playerRole">All-Rounder</div>
          </div>
        </div>
        
        <div class="stats-highlight">
          <div class="stat-box">
            <div class="stat-label">Matches</div>
            <div class="stat-value" id="playerMatches">0</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Batting Best</div>
            <div class="stat-value" id="playerBattingBest">N/A</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Bowling Best</div>
            <div class="stat-value" id="playerBowlingBest">N/A</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Bid Amount Display with Team Logo -->
    <div class="bid-display" id="bidDisplay">
      <div class="bid-team-logo-container" id="bidTeamLogoContainer">
        <img src="" alt="" class="bid-team-logo" id="bidTeamLogo" style="display: none;">
        <div class="bid-team-pulse" id="bidTeamPulse"></div>
      </div>
      <div class="bid-content">
        <div class="bid-label">Current Bid</div>
        <div class="bid-amount" id="bidAmount">‚Çπ0</div>
        <div class="bid-team-name" id="bidTeamName" style="display: none;"></div>
        <div class="bid-team-warning" id="bidTeamWarning" style="display: none;">
          <span class="warning-icon">‚ö†Ô∏è</span>
          <span class="warning-text" id="bidTeamWarningText"></span>
        </div>
        <div class="bid-confirm-hint" id="bidConfirmHint" style="display: none;">
          <kbd>ENTER</kbd> to Sell | <kbd>ESC</kbd> to Cancel
        </div>
      </div>
    </div>
    
    <!-- Bid Increment Info (Bottom Right Corner) -->
    <div class="bid-increment-info" id="bidIncrementInfo">
      <span class="increment-controls">
        <kbd>Q</kbd> <span class="decrement-arrow">‚ñº</span> | 
        <span class="increment-value" id="incrementValue">+‚Çπ100</span> | 
        <span class="increment-arrow">‚ñ≤</span> <kbd>W</kbd>
      </span>
    </div>
    
    <!-- Team Status Indicator (Bottom Left Corner) -->
    <div class="team-status-indicator" id="teamStatusIndicator">
      <!-- Teams will be populated dynamically -->
    </div>
    
    <!-- Hotkey Helper Button -->
    <button class="hotkey-helper-btn" id="hotkeyHelperBtn" onclick="toggleHotkeyHelper()" title="Keyboard Shortcuts (Press H)">
      ‚å®Ô∏è
    </button>
    
    <!-- Hotkey Helper Overlay -->
    <div class="hotkey-helper-overlay" id="hotkeyHelperOverlay">
      <div class="hotkey-helper-content">
        <button class="close-hotkey-btn" onclick="toggleHotkeyHelper()">√ó</button>
        <h2 class="hotkey-helper-title">‚å®Ô∏è Keyboard Shortcuts</h2>
        
        <div class="hotkey-section">
          <h3 class="hotkey-section-title">üéØ Team Bidding</h3>
          <div class="hotkey-grid">
            <div class="hotkey-item"><kbd>Q</kbd> <span>Decrease bid increment (‚àí‚Çπ50)</span></div>
            <div class="hotkey-item"><kbd>W</kbd> <span>Increase bid increment (+‚Çπ50)</span></div>
            <div class="hotkey-item"><kbd>1-9</kbd> <span>Team 1-9 places bid (by set increment)</span></div>
            <div class="hotkey-item"><kbd>S</kbd> <span>Show sell confirmation</span></div>
            <div class="hotkey-item"><kbd>ENTER</kbd> <span>Confirm sale (when S pressed)</span></div>
          </div>
        </div>
        
        <div class="hotkey-section">
          <h3 class="hotkey-section-title">üéÆ Navigation</h3>
          <div class="hotkey-grid">
            <div class="hotkey-item"><kbd>N</kbd> <span>Next player</span></div>
            <div class="hotkey-item"><kbd>U</kbd> <span>Mark as unsold</span></div>
            <div class="hotkey-item"><kbd>F</kbd> <span>Jump to player (by ID)</span></div>
            <div class="hotkey-item"><kbd>Space</kbd> <span>Toggle fullscreen</span></div>
          </div>
        </div>
        
        <div class="hotkey-section">
          <h3 class="hotkey-section-title">üìä Information</h3>
          <div class="hotkey-grid">
            <div class="hotkey-item"><kbd>I</kbd> <span>Show team statistics</span></div>
            <div class="hotkey-item"><kbd>M</kbd> <span>Show team selection menu</span></div>
            <div class="hotkey-item"><kbd>T</kbd>+<kbd>1-8</kbd> <span>View team squad (T then number)</span></div>
            <div class="hotkey-item"><kbd>H</kbd> <span>Toggle this help</span></div>
          </div>
        </div>
        
        <div class="hotkey-section">
          <h3 class="hotkey-section-title">‚úñÔ∏è Close</h3>
          <div class="hotkey-grid">
            <div class="hotkey-item"><kbd>ESC</kbd> <span>Close any overlay</span></div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="sold-overlay" id="soldOverlay">
      <div class="hammer" id="hammer">üî®</div>
      <div class="impact" id="impact"></div>
      <div class="stamp" id="stamp">
        <div class="stamp-content">
          <div class="stamp-text-container">
            <div class="stamp-text-top">PLAYER</div>
            <div class="stamp-text-main">SOLD</div>
            <div class="stamp-text-bottom">TO</div>
            <div class="stamp-text-team" id="stampTeamName">TEAM NAME</div>
          </div>
        </div>
      </div>
    </div>
    <div class="unsold-overlay" id="unsoldOverlay">
      <div class="unsold-x" id="unsoldX"></div>
      <div class="unsold-text" id="unsoldText">UNSOLD</div>
      <div class="unsold-subtext" id="unsoldSubtext">NO BIDDERS</div>
    </div>
    
    <!-- Coin Jar Random Selection Overlay -->
    <div class="coin-jar-overlay" id="coinJarOverlay">
      <div class="coin-jar-container">
        <div class="coin-jar">
          <div class="jar-body">
            <div class="coins-container" id="coinsContainer">
              <!-- Coins will be generated dynamically -->
            </div>
          </div>
          <div class="jar-lid"></div>
        </div>
        <div class="selected-coin" id="selectedCoin">
          <div class="coin-face">
            <span class="coin-number"></span>
          </div>
        </div>
        <div class="selection-text">Selecting Random Player...</div>
      </div>
    </div>
    
    <!-- Completion Prompt for Unsold Players -->
    <div class="completion-prompt" id="completionPrompt" onclick="restartUnsoldAuction()">
      ‚ôªÔ∏è Re-auction Unsold Players
    </div>
    
    <!-- Next Random Prompt (shown after sold/unsold in random mode) -->
    <div class="next-random-prompt" id="nextRandomPrompt">
      <span>Press</span> <kbd>ENTER</kbd> <span>to draw next player</span>
    </div>
    
    <!-- End Screen Overlay -->
    <div class="end-screen-overlay" id="endScreenOverlay">
      <img src="./assets/END.jpg" alt="Auction Complete" class="end-screen-image">
    </div>
    
    <!-- Start Screen Overlay -->
    <div class="start-screen-overlay" id="startScreenOverlay">
      <div class="start-screen-content">
        <div class="start-screen-title">üèè Cricket Auction</div>
        <div class="start-screen-subtitle">Player Bidding System</div>
        <button class="start-button" id="startButton">
          <span class="start-icon">‚ñ∂</span>
          <span>START AUCTION</span>
        </button>
        <div class="start-screen-hint">Click to begin and enable audio</div>
        <button class="reset-auction-button" id="resetAuctionButton" title="Reset auction and start fresh">‚ü≥</button>
      </div>
    </div>
    
    <!-- Team Selection Modal -->
    <div class="team-selection-modal" id="teamModal">
      <div class="team-modal-content">
        <div class="team-modal-title">Select Team</div>
        <div class="team-dropdown-container">
          <label class="team-dropdown-label">Team:</label>
          <select class="team-dropdown" id="teamDropdown" onchange="updateMaxBidIndicator()">
            <option value="">-- Select a Team --</option>
          </select>
        </div>
        <div id="maxBidIndicator" style="margin: 10px 0; padding: 10px; background: rgba(33, 150, 243, 0.1); border-left: 3px solid #2196F3; border-radius: 5px; font-size: 14px; color: #fff; display: none;">
          <strong>Max Allowed Bid:</strong> <span id="maxBidValue">‚Çπ0</span>
        </div>
        <div class="team-modal-buttons">
          <button class="team-modal-btn confirm" onclick="confirmTeamSelection()">Confirm</button>
          <button class="team-modal-btn cancel" onclick="cancelTeamSelection()">Cancel</button>
        </div>
      </div>
    </div>
    
    <!-- Jump to Player Input -->
    <input type="number" 
           id="jumpToPlayerInput" 
           placeholder="ID" 
           style="position: absolute; 
                  bottom: 10px; 
                  left: 10px; 
                  width: 60px; 
                  height: 30px; 
                  padding: 5px; 
                  font-size: 14px; 
                  background: rgba(0, 0, 0, 0.9); 
                  color: #2196F3; 
                  border: 2px solid #2196F3; 
                  border-radius: 5px; 
                  outline: none;
                  opacity: 0;
                  pointer-events: none;
                  transition: opacity 0.3s ease;
                  z-index: 15000;
                  box-shadow: 0 0 20px rgba(33, 150, 243, 0.8);" />
    </div>
  </div>

  <!-- Teams Information Overlay -->
  <div class="teams-info-overlay" id="teamsInfoOverlay">
    <button class="close-teams-btn" onclick="hideTeamsInfo()">√ó</button>
    <div class="teams-info-container">
      <div class="teams-info-header">
        <h1 class="teams-info-title">Team Statistics</h1>
        <p class="teams-info-subtitle">Live Auction Dashboard</p>
      </div>
      
      <table class="teams-table">
        <thead>
          <tr>
            <th>Logo</th>
            <th>Team Name</th>
            <th>Players Bought</th>
            <th>Under-18</th>
            <th>Remaining Players</th>
            <th>Purse Spent</th>
            <th>Remaining Purse</th>
            <th>Highest Bid</th>
          </tr>
        </thead>
        <tbody id="teamsTableBody">
          <!-- Teams will be populated dynamically -->
        </tbody>
      </table>
      
      <div class="teams-info-footer">
        Press 'I' to close ‚Ä¢ Data updates in real-time from Google Sheets
      </div>
    </div>
  </div>

  <!-- Team Slots View Overlay -->
  <div class="team-slots-overlay" id="teamSlotsOverlay">
    <button class="close-team-slots-btn" onclick="hideTeamSlots()">√ó</button>
    
    <!-- Team Selection Menu -->
    <div class="team-selection-menu" id="teamSelectionMenu">
      <div class="team-selection-menu-title">Select Team</div>
      <div id="teamMenuItems"></div>
    </div>
    
    <div class="team-slots-container" id="teamSlotsContainer">
      <!-- Content will be populated dynamically -->
    </div>
  </div>

  <!-- Load Configuration First -->
  <script src="./config.js"></script>
  
  <audio id="soldSound" preload="auto">
    <source id="soldSoundSource" src="./assets/sold.mp3" type="audio/mpeg">
  </audio>
  <audio id="unsoldSound" preload="auto">
    <source id="unsoldSoundSource" src="./assets/unsold.mp3" type="audio/mpeg">
  </audio>
  <audio id="coinShakeSound" preload="auto">
    <source id="coinShakeSoundSource" src="./assets/coinsshake.mp3" type="audio/mpeg">
  </audio>
  
  <script>
    // Configuration loaded from config.js
    const SHEET_ID = CONFIG.googleSheets.sheetId;
    const SHEET_RANGE = CONFIG.googleSheets.ranges.players;
    const TEAMS_SHEET_RANGE = CONFIG.googleSheets.ranges.teams;
    const SOLD_SHEET_RANGE = CONFIG.googleSheets.ranges.soldPlayers;
    const UNSOLD_SHEET_RANGE = CONFIG.googleSheets.ranges.unsoldPlayers;
    const API_KEY = CONFIG.googleSheets.apiKey;
    
    let items = [];
    let teams = [];
    let currentIndex = -1;
    let currentBid = 0;
    let basePrice = CONFIG.auction.basePrice;
    
    // Track unsold players and sold players
    let unsoldPlayers = [];
    let soldPlayers = [];
    let finallyUnsoldPlayers = []; // Players unsold in both rounds (won't be shown again)
    let unsoldRoundCount = {}; // Track how many times each player was unsold: { playerId: roundCount }
    let isShowingUnsoldRound = false;
    let allPlayersShown = false;
    let originalItemCount = 0; // Store the original count of items before any modifications
    
    // Initialize audio elements
    let soldSound = null;
    let unsoldSound = null;
    let coinShakeSound = null;
    
    // Image preloading cache
    const imageCache = new Map();
    
    // LocalStorage key for auction state
    const AUCTION_STATE_KEY = 'cricketAuctionState';
    
    // Save auction state to localStorage
    function saveAuctionState() {
      try {
        const currentPlayer = items[currentIndex];
        const state = {
          currentIndex,
          currentPlayerId: currentPlayer ? currentPlayer.id : null, // Save player ID for reliable restore
          currentBid,
          basePrice,
          currentBidIncrement,
          lastBiddingTeam,
          lastBiddingTeamIndex,
          unsoldPlayers: unsoldPlayers.map(p => p.id), // Store only IDs
          soldPlayers: soldPlayers.map(p => p.id), // Store only IDs
          finallyUnsoldPlayers: finallyUnsoldPlayers.map(p => p.id), // Players unsold twice
          unsoldRoundCount: unsoldRoundCount, // Track rounds for each player
          isShowingUnsoldRound,
          allPlayersShown,
          originalItemCount, // Save the original count for accurate round tracking
          // Save team stats including underAgePlayers count
          teamStats: teams.map(team => ({
            name: team.name,
            playersBought: team.playersBought,
            remainingPlayers: team.remainingPlayers,
            remainingPurse: team.remainingPurse,
            highestBid: team.highestBid,
            underAgePlayers: team.underAgePlayers || 0
          })),
          timestamp: Date.now()
        };
        localStorage.setItem(AUCTION_STATE_KEY, JSON.stringify(state));
        console.debug('[STATE] Auction state saved - currentPlayer:', currentPlayer?.name, '(ID:', currentPlayer?.id, ') currentBid:', currentBid, 'lastBiddingTeam:', lastBiddingTeam, 'bidIncrement:', currentBidIncrement);
      } catch (e) {
        console.error('[STATE] Failed to save auction state:', e);
      }
    }
    
    // Save bid history to localStorage
    function saveBidHistory() {
      try {
        localStorage.setItem(UNDO_HISTORY_KEY, JSON.stringify(bidHistory));
        console.debug('[UNDO] Bid history saved -', bidHistory.length, 'entries');
      } catch (e) {
        console.error('[UNDO] Failed to save bid history:', e);
      }
    }
    
    // Restore bid history from localStorage
    function restoreBidHistory() {
      try {
        const savedHistory = localStorage.getItem(UNDO_HISTORY_KEY);
        if (savedHistory) {
          bidHistory = JSON.parse(savedHistory);
          console.debug('[UNDO] Bid history restored -', bidHistory.length, 'entries');
        }
      } catch (e) {
        console.error('[UNDO] Failed to restore bid history:', e);
        bidHistory = [];
      }
    }
    
    // Add bid to history
    function addBidToHistory(bidAmount, teamIndex, teamName) {
      if (!CONFIG.auction.undo.enabled) return;
      
      const bidEntry = {
        bidAmount: bidAmount,
        teamIndex: teamIndex,
        teamName: teamName,
        timestamp: Date.now()
      };
      
      bidHistory.unshift(bidEntry); // Add to beginning
      
      // Keep only the last X bids as configured
      if (bidHistory.length > CONFIG.auction.undo.historySize) {
        bidHistory = bidHistory.slice(0, CONFIG.auction.undo.historySize);
      }
      
      saveBidHistory();
      console.debug('[UNDO] Bid added to history:', bidEntry);
      
      // Update undo button state
      updateUndoButtonState();
    }
    
    // Undo last bid
    function undoLastBid() {
      if (!CONFIG.auction.undo.enabled || bidHistory.length === 0) {
        console.debug('[UNDO] No bids to undo or undo disabled');
        return false;
      }
      
      const lastBid = bidHistory.shift(); // Remove from beginning
      const team = teams[lastBid.teamIndex];
      
      if (!team) {
        console.error('[UNDO] Team not found for undo operation');
        return false;
      }
      
      // Revert the bid amount
      currentBid = lastBid.bidAmount;
      updateBidDisplay();
      
      // Clear the last bidding team
      lastBiddingTeam = null;
      lastBiddingTeamIndex = null;
      clearBidTeamDisplay();
      
      // Save updated history and state
      saveBidHistory();
      saveAuctionState();
      
      // Update undo button state
      updateUndoButtonState();
      
      console.debug('[UNDO] Undid bid by', lastBid.teamName, '- reverted to ‚Çπ' + currentBid.toLocaleString());
      showNotification(`Undid bid by ${lastBid.teamName} - reverted to ‚Çπ${currentBid.toLocaleString()}`, 'info');
      
      return true;
    }
    
    // Update undo button state (enabled/disabled)
    function updateUndoButtonState() {
      const undoButton = document.getElementById('undoButton');
      if (undoButton) {
        const hasHistory = bidHistory.length > 0 && CONFIG.auction.undo.enabled;
        undoButton.disabled = !hasHistory;
        undoButton.style.opacity = hasHistory ? '1' : '0.3';
      }
    }
    
    // Restore auction state from localStorage
    function restoreAuctionState() {
      try {
        const savedState = localStorage.getItem(AUCTION_STATE_KEY);
        if (!savedState) return false;
        
        const state = JSON.parse(savedState);
        
        // Check if state is recent (within 24 hours)
        const hoursSinceLastSave = (Date.now() - state.timestamp) / (1000 * 60 * 60);
        if (hoursSinceLastSave > 24) {
          console.debug('[STATE] Saved state is too old, starting fresh');
          return false;
        }
        
        // Restore state
        currentBid = state.currentBid || 0;
        basePrice = state.basePrice || 0;
        currentBidIncrement = state.currentBidIncrement || CONFIG.auction.bidIncrements.default;
        lastBiddingTeam = state.lastBiddingTeam || null;
        lastBiddingTeamIndex = state.lastBiddingTeamIndex !== undefined ? state.lastBiddingTeamIndex : null;
        isShowingUnsoldRound = state.isShowingUnsoldRound;
        allPlayersShown = state.allPlayersShown;
        originalItemCount = state.originalItemCount || items.length; // Restore original count or fallback to current items length
        
        // Restore unsold players (find by ID)
        unsoldPlayers = state.unsoldPlayers.map(id => 
          items.find(item => item.id === id)
        ).filter(p => p); // Remove undefined
        
        // Restore sold players (find by ID)
        soldPlayers = state.soldPlayers.map(id => 
          items.find(item => item.id === id)
        ).filter(p => p); // Remove undefined
        
        // Restore finally unsold players (find by ID)
        finallyUnsoldPlayers = (state.finallyUnsoldPlayers || []).map(id => 
          items.find(item => item.id === id)
        ).filter(p => p); // Remove undefined
        
        // Restore unsold round count
        unsoldRoundCount = state.unsoldRoundCount || {};
        
        // Restore team stats including underAgePlayers count
        if (state.teamStats && Array.isArray(state.teamStats)) {
          state.teamStats.forEach(savedTeam => {
            const team = teams.find(t => t.name === savedTeam.name);
            if (team) {
              team.playersBought = savedTeam.playersBought;
              team.remainingPlayers = savedTeam.remainingPlayers;
              team.remainingPurse = savedTeam.remainingPurse;
              team.highestBid = savedTeam.highestBid;
              team.underAgePlayers = savedTeam.underAgePlayers || 0;
            }
          });
          console.debug('[STATE] Team stats restored including under-age player counts');
        }
        
        // Find current player by ID (more reliable than index when items array changes)
        if (state.currentPlayerId) {
          const playerIndex = items.findIndex(item => item.id === state.currentPlayerId);
          if (playerIndex !== -1) {
            currentIndex = playerIndex;
            console.debug('[STATE] Found player by ID:', state.currentPlayerId, 'at index:', currentIndex);
          } else {
            console.warn('[STATE] Could not find player with ID:', state.currentPlayerId, '- using saved index:', state.currentIndex);
            currentIndex = state.currentIndex;
          }
        } else {
          currentIndex = state.currentIndex;
        }
        
        console.debug('[STATE] Auction state restored - currentIndex:', currentIndex, 'player:', items[currentIndex]?.name, 'currentBid:', currentBid, 'basePrice:', basePrice, 'lastBiddingTeam:', lastBiddingTeam, 'bidIncrement:', currentBidIncrement);
        
        // Restore bid history
        restoreBidHistory();
        
        return true;
      } catch (e) {
        console.error('[STATE] Failed to restore auction state:', e);
        return false;
      }
    }
    
    // Clear auction state from localStorage
    function clearAuctionState() {
      try {
        localStorage.removeItem(AUCTION_STATE_KEY);
        localStorage.removeItem(UNDO_HISTORY_KEY);
        bidHistory = []; // Clear in-memory history
        console.debug('[STATE] Auction state and bid history cleared');
      } catch (e) {
        console.error('[STATE] Failed to clear auction state:', e);
      }
    }
    
    // Webhook functions to update Google Sheets
    async function sendToWebhook(action, playerData) {
      if (!CONFIG.webhook.url) {
        console.debug('[WEBHOOK] No webhook URL configured, skipping');
        return;
      }
      
      try {
        const response = await fetch(CONFIG.webhook.url, {
          method: 'POST',
          mode: 'no-cors',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            action: action,
            ...playerData
          })
        });
        
        console.debug('[WEBHOOK] Sent', action, 'for player:', playerData.playerName);
        
        // If this was a sold player action, refresh teams data after delay
        if (action === 'updateSoldPlayer' || action === 'moveUnsoldToSold') {
          setTimeout(async () => {
            console.debug('[WEBHOOK] Fetching updated teams data after', action, '...');
            await fetchTeamsData();
            console.debug('[WEBHOOK] Teams data refreshed successfully');
          }, CONFIG.webhook.updateDelay);
        }
      } catch (error) {
        console.error('[WEBHOOK] Error sending', action, ':', error);
      }
    }
    
    async function updateSoldPlayerSheet(player, team, soldPrice, basePrice) {
      console.debug('[WEBHOOK] updateSoldPlayerSheet - Team stats being sent:', {
        teamName: team.name,
        playersBought: team.playersBought,
        underAgePlayers: team.underAgePlayers,
        remainingPlayers: team.remainingPlayers,
        remainingPurse: team.remainingPurse,
        highestBid: team.highestBid
      });
      
      await sendToWebhook('updateSoldPlayer', {
        playerId: player.id,
        playerName: player.name,
        role: player.role,
        age: player.age,
        matches: player.matches,
        battingBest: player.battingBestFigures || 'N/A',
        bowlingBest: player.bowlingBestFigures || 'N/A',
        teamName: team.name,
        soldPrice: soldPrice,
        basePrice: basePrice,
        imageUrl: player.imageUrl || '',
        // Include team stats for updating Teams sheet
        teamPlayersBought: team.playersBought,
        teamU19PlayersBought: team.underAgePlayers,
        teamRemainingPlayers: team.remainingPlayers,
        teamRemainingPurse: team.remainingPurse,
        teamHighestBid: team.highestBid
      });
    }
    
    async function updateUnsoldPlayerSheet(player, basePrice, round) {
      await sendToWebhook('updateUnsoldPlayer', {
        playerId: player.id,
        playerName: player.name,
        role: player.role,
        age: player.age,
        matches: player.matches,
        battingBest: player.battingBestFigures || 'N/A',
        bowlingBest: player.bowlingBestFigures || 'N/A',
        basePrice: basePrice,
        round: round,
        imageUrl: player.imageUrl || ''
      });
    }
    
    async function moveUnsoldToSoldSheet(player, team, soldPrice, basePrice) {
      console.debug('[WEBHOOK] moveUnsoldToSoldSheet - Team stats being sent:', {
        teamName: team.name,
        playersBought: team.playersBought,
        underAgePlayers: team.underAgePlayers,
        remainingPlayers: team.remainingPlayers,
        remainingPurse: team.remainingPurse,
        highestBid: team.highestBid
      });
      
      await sendToWebhook('moveUnsoldToSold', {
        playerId: player.id,
        playerName: player.name,
        role: player.role,
        age: player.age,
        matches: player.matches,
        battingBest: player.battingBestFigures || 'N/A',
        bowlingBest: player.bowlingBestFigures || 'N/A',
        teamName: team.name,
        soldPrice: soldPrice,
        basePrice: basePrice,
        imageUrl: player.imageUrl || '',
        // Include team stats for updating Teams sheet
        teamPlayersBought: team.playersBought,
        teamU19PlayersBought: team.underAgePlayers,
        teamRemainingPlayers: team.remainingPlayers,
        teamRemainingPurse: team.remainingPurse,
        teamHighestBid: team.highestBid
      });
    }
    
    // Performance optimization: Preload images efficiently
    
    // Track last bidding team
    let lastBiddingTeam = null;
    let lastBiddingTeamIndex = null;
    
    // Track 't' key press for team slots
    let tKeyPressed = false;
    let tKeyTimeout = null;
    
    // Track current bid increment (dynamic)
    let currentBidIncrement = CONFIG.auction.bidIncrements.default;
    
    // Undo functionality
    let bidHistory = []; // Array of {bidAmount, teamIndex, teamName, timestamp}
    const UNDO_HISTORY_KEY = 'auctionBidHistory';
    
    // Auction Rules Validation System (Dynamically uses CONFIG values)
    const AUCTION_RULES = {
      // Dynamic getters to always use current CONFIG values
      get minimumPlayerBasePrice() {
        return CONFIG.auction.rules.minimumPlayerBasePrice;
      },
      get safeFundBufferPercent() {
        return CONFIG.auction.rules.safeFundBufferPercent;
      },
      get underAgeLimit() {
        return CONFIG.auction.rules.underAgeLimit;
      },
      get maxUnderAgePlayers() {
        return CONFIG.auction.rules.maxUnderAgePlayers;
      },
      
      // RULE_001 & RULE_002: Remaining Budget Constraint & Dynamic Max Bid
      calculateMaxBid: function(team) {
        if (team.remainingPlayers <= 0) return 0;
        const maxBid = team.remainingPurse - (team.remainingPlayers - 1) * this.minimumPlayerBasePrice;
        return Math.max(0, maxBid);
      },
      
      // RULE_003: Total Budget Cap
      validateTotalBudget: function(team, bidAmount) {
        const totalSpent = team.allocatedAmount - team.remainingPurse;
        return totalSpent + bidAmount <= team.allocatedAmount;
      },
      
      // RULE_004: Player Count Limit
      validatePlayerCount: function(team) {
        return team.playersBought < team.totalPlayerThreshold;
      },
      
      // RULE_005: Minimum Participation Balance
      validateMinimumBalance: function(team, playerBasePrice) {
        return team.remainingPurse >= playerBasePrice;
      },
      
      // RULE_006: Safe Fund Threshold (configurable buffer)
      validateSafeFundThreshold: function(team, bidAmount) {
        if (team.remainingPlayers <= 1) return true; // Last player, no need for buffer
        const safeThreshold = (team.remainingPlayers - 1) * this.minimumPlayerBasePrice * this.safeFundBufferPercent;
        return (team.remainingPurse - bidAmount) >= safeThreshold;
      },
      
      // RULE_009: Under-Age Player Limit
      validateUnderAgeLimit: function(team, playerAge) {
        // If player is not under-age, always valid
        if (!playerAge || playerAge >= this.underAgeLimit) {
          return true;
        }
        // If player is under-age, check if team has reached the limit
        return (team.underAgePlayers || 0) < this.maxUnderAgePlayers;
      },
      
      // Comprehensive validation
      validateBid: function(team, bidAmount, playerBasePrice = this.minimumPlayerBasePrice, playerAge = null) {
        const validations = [];
        
        // RULE_004: Check player count
        if (!this.validatePlayerCount(team)) {
          return {
            valid: false,
            severity: 'critical',
            message: `Team roster full. ${team.name} cannot buy more players.`,
            ruleId: 'RULE_004'
          };
        }
        
        // RULE_003: Check total budget
        if (!this.validateTotalBudget(team, bidAmount)) {
          return {
            valid: false,
            severity: 'critical',
            message: `Insufficient funds! ${team.name} cannot exceed allocated total budget.`,
            ruleId: 'RULE_003'
          };
        }
        
        // RULE_005: Check minimum balance
        if (!this.validateMinimumBalance(team, playerBasePrice)) {
          return {
            valid: false,
            severity: 'warning',
            message: `Insufficient balance to bid for this player. ${team.name} needs at least ‚Çπ${playerBasePrice.toLocaleString()}.`,
            ruleId: 'RULE_005'
          };
        }
        
        // RULE_009: Check under-age player limit
        if (playerAge && playerAge < this.underAgeLimit) {
          if (!this.validateUnderAgeLimit(team, playerAge)) {
            return {
              valid: false,
              severity: 'critical',
              message: `${team.name} has reached maximum limit of under-${this.underAgeLimit} players (max ${this.maxUnderAgePlayers} allowed).`,
              ruleId: 'RULE_009'
            };
          }
        }
        
        // RULE_001 & RULE_002: Check remaining budget constraint
        const maxBid = this.calculateMaxBid(team);
        if (bidAmount > maxBid) {
          return {
            valid: false,
            severity: 'critical',
            message: `Bid exceeds allowed limit! ${team.name} must retain enough funds to complete the team. Max allowed: ‚Çπ${maxBid.toLocaleString()}`,
            ruleId: 'RULE_001'
          };
        }
        
        // RULE_006: Check safe fund threshold (warning only)
        if (!this.validateSafeFundThreshold(team, bidAmount)) {
          return {
            valid: true,
            severity: 'warning',
            message: `Warning: ${team.name} is entering unsafe fund range. Consider preserving funds for upcoming players.`,
            ruleId: 'RULE_006',
            isWarning: true
          };
        }
        
        return {
          valid: true,
          severity: 'info',
          message: 'Bid is valid.',
          ruleId: null
        };
      },
      
      // Helper function to get current rule configuration
      getCurrentRules: function() {
        return {
          minimumPlayerBasePrice: this.minimumPlayerBasePrice,
          safeFundBufferPercent: this.safeFundBufferPercent,
          basePrice: basePrice,
          bidIncrements: {
            current: currentBidIncrement,
            default: CONFIG.auction.bidIncrements.default,
            minimum: CONFIG.auction.bidIncrements.minimum,
            maximum: CONFIG.auction.bidIncrements.maximum,
            adjustmentStep: CONFIG.auction.bidIncrements.adjustmentStep
          },
          teamStatsThresholds: CONFIG.ui.teamStatsThresholds
        };
      },
      
      // Helper function to log current rules (for debugging)
      logRules: function() {
        console.debug('[AUCTION_RULES] Current auction rules configuration:');
        console.debug('[AUCTION_RULES] - Minimum Player Base Price:', this.minimumPlayerBasePrice);
        console.debug('[AUCTION_RULES] - Safe Fund Buffer Percent:', this.safeFundBufferPercent);
        console.debug('[AUCTION_RULES] - Base Price:', basePrice);
        console.debug('[AUCTION_RULES] - Current Bid Increment:', currentBidIncrement);
        console.debug('[AUCTION_RULES] - Bid Increment Range:', CONFIG.auction.bidIncrements.minimum, '-', CONFIG.auction.bidIncrements.maximum);
        console.debug('[AUCTION_RULES] - Team Stats Thresholds:', CONFIG.ui.teamStatsThresholds);
      }
    };
    
    function preloadImage(url) {
      if (!url || url.trim() === '' || imageCache.has(url)) {
        return Promise.resolve();
      }
      
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          imageCache.set(url, img);
          console.debug('[IMAGE_CACHE] Preloaded image:', url.substring(0, 50) + '...');
          resolve(img);
        };
        img.onerror = () => {
          console.warn('‚ö†Ô∏è Failed to preload image:', url.substring(0, 50) + '...');
          reject();
        };
        img.src = url;
      });
    }
    
    function preloadNextImages(currentIdx, count = 3) {
      // Preload the next 'count' player images (optimized - only if not cached)
      for (let i = 1; i <= count; i++) {
        const nextIndex = (currentIdx + i) % items.length;
        if (items[nextIndex] && items[nextIndex].imageUrl) {
          const imageUrl = convertDriveLinkToDirect(items[nextIndex].imageUrl);
          if (!imageCache.has(imageUrl)) {
            preloadImage(imageUrl).catch(() => {});
          }
        }
      }
    }
    
    function preloadAllPlayerImages() {
      // Optimized: Only preload if not already cached
      if (imageCache.size >= items.length * 0.5) {
        console.debug('[IMAGE_CACHE] Most images already cached, skipping bulk preload');
        return;
      }
      
      console.debug('[IMAGE_CACHE] Starting to preload player images...');
      const promises = items.slice(0, 10).map(item => { // Preload only first 10
        if (item && item.imageUrl) {
          const imageUrl = convertDriveLinkToDirect(item.imageUrl);
          if (!imageCache.has(imageUrl)) {
            return preloadImage(imageUrl).catch(() => {});
          }
        }
        return Promise.resolve();
      });
      
      Promise.all(promises).then(() => {
        console.debug(`[IMAGE_CACHE] Preloaded ${imageCache.size} images`);
        // Lazy load remaining images in background
        setTimeout(() => {
          items.slice(10).forEach(item => {
            if (item && item.imageUrl) {
              const imageUrl = convertDriveLinkToDirect(item.imageUrl);
              if (!imageCache.has(imageUrl)) {
                preloadImage(imageUrl).catch(() => {});
              }
            }
          });
        }, 2000); // Delay by 2 seconds
      });
    }
    
    function preloadTeamLogos() {
      console.debug('[IMAGE_CACHE] Preloading team logos...');
      teams.forEach(team => {
        if (team && team.logoUrl) {
          const logoUrl = convertDriveLinkToDirect(team.logoUrl);
          if (!imageCache.has(logoUrl)) {
            preloadImage(logoUrl).catch(() => {});
          }
        }
      });
    }
    
    function initializeAudio() {
      // Set audio sources from config
      document.getElementById('soldSoundSource').src = CONFIG.audio.files.sold;
      document.getElementById('unsoldSoundSource').src = CONFIG.audio.files.unsold;
      document.getElementById('coinShakeSoundSource').src = './assets/coinsshake.mp3';
      
      soldSound = document.getElementById('soldSound');
      unsoldSound = document.getElementById('unsoldSound');
      coinShakeSound = document.getElementById('coinShakeSound');
      
      // Set volume from config BEFORE loading
      if (soldSound) soldSound.volume = CONFIG.audio.volume;
      if (unsoldSound) unsoldSound.volume = CONFIG.audio.volume;
      if (coinShakeSound) coinShakeSound.volume = CONFIG.audio.volume;
      
      // Load audio files
      soldSound.load();
      unsoldSound.load();
      coinShakeSound.load();
      
      // Log audio readiness
      soldSound.addEventListener('canplaythrough', () => {
        console.debug('[AUDIO] Sold sound ready to play (canplaythrough) - Ready state:', soldSound.readyState, 'Duration:', soldSound.duration);
      });
      unsoldSound.addEventListener('canplaythrough', () => {
        console.debug('[AUDIO] Unsold sound ready to play (canplaythrough)');
      });
      
      soldSound.addEventListener('loadeddata', () => {
        console.debug('[AUDIO] Sold sound data loaded');
      });
      
      // Log errors
      soldSound.addEventListener('error', (e) => {
        console.error('‚úó Sold sound error:', e, soldSound.error);
        if (soldSound.error) {
          console.error('  Error code:', soldSound.error.code);
          console.error('  Error message:', soldSound.error.message);
        }
      });
      unsoldSound.addEventListener('error', (e) => {
        console.error('‚úó Unsold sound error:', e, unsoldSound.error);
      });
      
      // Unlock audio on first user interaction (for browser autoplay policy)
      const unlockAudio = () => {
        console.debug('[AUDIO] Unlocking audio on user interaction...');
        
        // Unlock sold sound
        const soldPromise = soldSound.play().then(() => {
          soldSound.pause();
          soldSound.currentTime = 0;
          console.debug('[AUDIO] Sold audio unlocked successfully');
        }).catch(e => {
          console.warn('‚ö†Ô∏è Sold audio unlock failed:', e.name, e.message);
        });
        
        // Unlock unsold sound
        const unsoldPromise = unsoldSound.play().then(() => {
          unsoldSound.pause();
          unsoldSound.currentTime = 0;
          console.debug('[AUDIO] Unsold audio unlocked successfully');
        }).catch(e => {
          console.warn('‚ö†Ô∏è Unsold audio unlock failed:', e.name, e.message);
        });
        
        // Unlock coin shake sound
        const coinShakePromise = coinShakeSound.play().then(() => {
          coinShakeSound.pause();
          coinShakeSound.currentTime = 0;
          console.debug('[AUDIO] Coin shake audio unlocked successfully');
        }).catch(e => {
          console.warn('‚ö†Ô∏è Coin shake audio unlock failed:', e.name, e.message);
        });
        
        Promise.all([soldPromise, unsoldPromise, coinShakePromise]).then(() => {
          console.debug('[AUDIO] All audio elements unlocked successfully');
        });
      };
      
      // Listen for first user interaction
      document.addEventListener('click', unlockAudio, { once: true });
      document.addEventListener('touchstart', unlockAudio, { once: true });
    }
    
    function playSoldSound() {
      if (!soldSound) {
        console.error('‚úó Sold sound element not found');
        return;
      }
      
      console.debug('[AUDIO] Attempting to play sold sound - Ready state:', soldSound.readyState, 'Source:', soldSound.src || soldSound.currentSrc, 'Volume:', soldSound.volume, 'Muted:', soldSound.muted);
      
      // Function to actually play the sound
      const attemptPlay = () => {
        soldSound.currentTime = 0; // Reset to start
        
        const playPromise = soldSound.play();
        
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              console.debug('[AUDIO] Sold sound playing successfully - Duration:', soldSound.duration);
            })
            .catch(e => {
              console.error('‚úó Error playing sold sound:', e);
              console.error('Error name:', e.name);
              console.error('Error message:', e.message);
              if (soldSound.error) {
                console.error('Audio error code:', soldSound.error.code);
                console.error('Audio error message:', soldSound.error.message);
              }
              
              // Try to provide helpful feedback
              if (e.name === 'NotAllowedError') {
                console.warn('‚ö†Ô∏è Audio playback blocked by browser. User interaction may be required.');
                console.warn('üí° Try clicking anywhere on the page first to enable audio.');
              } else if (e.name === 'NotSupportedError') {
                console.error('‚ö†Ô∏è Audio format not supported or file cannot be loaded.');
              }
            });
        }
      };
      
      // Check if audio is ready to play (readyState >= 3 means HAVE_FUTURE_DATA)
      if (soldSound.readyState >= 3) {
        console.debug('[AUDIO] Audio is ready (readyState >= 3), playing immediately');
        attemptPlay();
      } else {
        console.debug('[AUDIO] Audio not fully loaded (readyState:', soldSound.readyState + '), waiting for canplay event...');
        // Wait for audio to be ready
        soldSound.addEventListener('canplay', function onCanPlay() {
          console.debug('[AUDIO] Audio now ready after waiting, attempting playback');
          soldSound.removeEventListener('canplay', onCanPlay);
          attemptPlay();
        }, { once: true });
        
        // Also reload the audio to ensure it loads
        soldSound.load();
      }
    }
    
    function playUnsoldSound() {
      if (!unsoldSound) {
        console.error('‚úó Unsold sound element not found');
        return;
      }
      
      console.debug('[AUDIO] Attempting to play unsold sound...');
      unsoldSound.currentTime = 0; // Reset to start
      
      const playPromise = unsoldSound.play();
      
      if (playPromise !== undefined) {
        playPromise
          .then(() => console.debug('[AUDIO] Unsold sound playing successfully'))
          .catch(e => {
            console.error('‚úó Error playing unsold sound:', e);
            if (e.name === 'NotAllowedError') {
              console.warn('‚ö†Ô∏è Audio playback blocked by browser. User interaction may be required.');
            }
          });
      }
    }
    
    function playCoinShakeSound() {
      if (!coinShakeSound) {
        console.error('‚úó Coin shake sound element not found');
        return;
      }
      
      console.debug('[AUDIO] Attempting to play coin shake sound...');
      coinShakeSound.currentTime = 0; // Reset to start
      
      const playPromise = coinShakeSound.play();
      
      if (playPromise !== undefined) {
        playPromise
          .then(() => console.debug('[AUDIO] Coin shake sound playing successfully'))
          .catch(e => {
            console.error('‚úó Error playing coin shake sound:', e);
            if (e.name === 'NotAllowedError') {
              console.warn('‚ö†Ô∏è Audio playback blocked by browser. User interaction may be required.');
            }
          });
      }
    }

    // Fetch already sold players from the Sold Players sheet
    async function fetchAlreadySoldPlayers() {
      try {
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(SOLD_SHEET_RANGE)}?key=${API_KEY}`;
        const resp = await fetch(url);
        const data = await resp.json();
        
        if (!data.values || data.values.length === 0) {
          console.debug('[DATA_FETCH] No sold players found in sheet');
          return { ids: [], players: [] };
        }
        
        const cols = CONFIG.columnMappings.soldPlayers;
        const soldPlayerIds = [];
        const soldPlayerObjects = [];
        
        // Skip header row and collect player IDs and full player objects
        for (let i = 1; i < data.values.length; i++) {
          const row = data.values[i];
          const playerId = row[cols.id] || '';
          if (playerId && playerId.trim() !== '') {
            soldPlayerIds.push(playerId.trim());
            
            // Create player object from sold sheet data
            const playerObj = {
              id: playerId.trim(),
              imageUrl: row[cols.imageUrl] || '',
              name: row[cols.name] || 'Unknown Player',
              role: row[cols.role] || 'Player',
              age: row[cols.age] ? parseInt(row[cols.age]) : null,
              matches: row[cols.matches] || '0',
              battingBestFigures: row[cols.bestFigures] || 'N/A',
              bowlingBestFigures: row[cols.bestFigures] || 'N/A',
              basePrice: row[cols.soldAmount] || '0' // Use sold amount as base price for display
            };
            soldPlayerObjects.push(playerObj);
          }
        }
        
        console.debug('[DATA_FETCH] Found', soldPlayerIds.length, 'already sold players in sheet');
        return { ids: soldPlayerIds, players: soldPlayerObjects };
      } catch (error) {
        console.error('Error fetching already sold players:', error);
        return { ids: [], players: [] };
      }
    }

    // Fetch unsold players from the Unsold Players sheet
    async function fetchAlreadyUnsoldPlayers() {
      try {
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(UNSOLD_SHEET_RANGE)}?key=${API_KEY}`;
        const resp = await fetch(url);
        const data = await resp.json();
        
        if (!data.values || data.values.length === 0) {
          console.debug('[DATA_FETCH] No unsold players found in sheet');
          return { ids: [], players: [] };
        }
        
        const cols = CONFIG.columnMappings.unsoldPlayers;
        const unsoldPlayerIds = [];
        const unsoldPlayerObjects = [];
        
        // Skip header row and collect player IDs and full player objects (only Round 1, not "Round 2 - Final")
        for (let i = 1; i < data.values.length; i++) {
          const row = data.values[i];
          const playerId = row[cols.id] || '';
          const round = row[cols.round] || '';
          
          if (playerId && playerId.trim() !== '' && round.includes('Round 1')) {
            unsoldPlayerIds.push(playerId.trim());
            
            // Create player object from unsold sheet data
            const playerObj = {
              id: playerId.trim(),
              imageUrl: row[cols.imageUrl] || '',
              name: row[cols.name] || 'Unknown Player',
              role: row[cols.role] || 'Player',
              age: row[cols.age] ? parseInt(row[cols.age]) : null,
              matches: row[cols.matches] || '0',
              battingBestFigures: row[cols.bestFigures] || 'N/A',
              bowlingBestFigures: row[cols.bestFigures] || 'N/A',
              basePrice: row[cols.basePrice] || '0'
            };
            unsoldPlayerObjects.push(playerObj);
          }
        }
        
        console.debug('[DATA_FETCH] Found', unsoldPlayerIds.length, 'unsold players (Round 1) in sheet');
        return { ids: unsoldPlayerIds, players: unsoldPlayerObjects };
      } catch (error) {
        console.error('Error fetching unsold players:', error);
        return { ids: [], players: [] };
      }
    }

    async function fetchSheetData() {
      // First, fetch already sold and unsold players from sheets
      const soldData = await fetchAlreadySoldPlayers();
      const unsoldData = await fetchAlreadyUnsoldPlayers();
      
      // Populate soldPlayers and unsoldPlayers arrays from sheet data
      soldPlayers = soldData.players;
      unsoldPlayers = unsoldData.players;
      
      console.debug('[DATA_FETCH] Loaded from sheets:', soldPlayers.length, 'sold players,', unsoldPlayers.length, 'unsold players');
      
      const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(SHEET_RANGE)}?key=${API_KEY}`;
      const resp = await fetch(url);
      const data = await resp.json();
      console.debug('[DATA_FETCH] Fetched player sheet data - Rows:', data.values?.length || 0);
      if (!data.values) {
        console.error('No data found in sheet');
        return;
      }
      // Map sheet columns using CONFIG.columnMappings.players
      const cols = CONFIG.columnMappings.players;
      
      // Filter and map - only include players with valid base price and not already sold
      items = data.values
        .map((row, index) => {
          // Skip if no base price or base price is N/A
          if (!row[cols.basePrice] || row[cols.basePrice].trim() === '' || row[cols.basePrice].trim() === 'N/A') {
            return null;
          }

          const playerId = row[cols.id] || `P${String(index + 1).padStart(3, '0')}`;
          
          // Skip if player is already sold (exists in Sold Players sheet)
          if (soldData.ids.includes(playerId.trim())) {
            console.debug('[DATA_FETCH] Skipping already sold player:', playerId, row[cols.name]);
            return null;
          }
          
          // Calculate or extract age from DOB column
          let age = null;
          const dobValue = row[cols.dateOfBirth];
          if (dobValue && dobValue.trim() !== '') {
            // First, check if it's a number (direct age)
            const ageNumber = parseInt(dobValue);
            if (!isNaN(ageNumber) && ageNumber > 0 && ageNumber < 120) {
              // It's a direct age number
              age = ageNumber;
            } else {
              // Try to parse it as a date
              const dobDate = new Date(dobValue);
              if (!isNaN(dobDate.getTime())) {
                // Valid date - calculate age
                const today = new Date();
                age = today.getFullYear() - dobDate.getFullYear();
                const monthDiff = today.getMonth() - dobDate.getMonth();
                if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < dobDate.getDate())) {
                  age--;
                }
              }
            }
          }
          
          return {
            id: playerId,
            imageUrl: row[cols.imageUrl] || '',
            name: row[cols.name] || 'Unknown Player',
            role: row[cols.role] || 'Player',
            age: age,
            matches: row[cols.matches] || '0',
            runs: row[cols.runs] || 'N/A',
            wickets: row[cols.wickets] || 'N/A',
            bowlingBestFigures: row[cols.bowlingBest] || 'N/A',
            battingBestFigures: row[cols.battingBest] || 'N/A',
            basePrice: row[cols.basePrice]
          };
        })
        .filter(player => player !== null); // Remove null entries
      
      // Store the original count before any modifications
      originalItemCount = items.length;
      
      // Note: soldPlayers and unsoldPlayers arrays are already populated from sheet data above
      // They don't need to be filtered from items array
      
      console.debug('[DATA_FETCH] Loaded', items.length, 'players for auction');
      console.debug('[DATA_FETCH] Already sold:', soldPlayers.length, 'players');
      console.debug('[DATA_FETCH] Already unsold (Round 1):', unsoldPlayers.length, 'players');
      console.debug('[DATA_FETCH] Excluded:', soldData.ids.length, 'sold players from items');
    }

    async function fetchTeamsData() {
      const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(TEAMS_SHEET_RANGE)}?key=${API_KEY}`;
      try {
        const resp = await fetch(url);
        const data = await resp.json();
        console.debug('[DATA_FETCH] Fetched teams data - Rows:', data.values?.length || 0);
        if (!data.values) {
          console.error('No teams found in sheet');
          return;
        }
        // Map team columns using CONFIG.columnMappings.teams
        const cols = CONFIG.columnMappings.teams;
        teams = data.values.map((row, index) => {
          const totalPlayerThreshold = parseInt(row[cols.totalPlayerThreshold]) || 11;
          const playersBought = parseInt(row[cols.playersBought]) || 0;
          const underAgePlayers = parseInt(row[cols.underAgePlayers]) || 0;
          const remainingPurse = parseFloat(row[cols.remainingPurse]) || 0;
          const highestBid = parseFloat(row[cols.highestBid]) || 0;
          
          console.debug('[DATA_FETCH] Team from sheet:', {
            name: row[cols.name],
            playersBought: playersBought,
            underAgePlayers: underAgePlayers,
            remainingPurse: remainingPurse,
            highestBid: highestBid
          });
          
          return {
            name: row[cols.name] || `Team ${index + 1}`,
            logoUrl: row[cols.logoUrl] || '',
            playersBought: playersBought,
            totalPlayerThreshold: totalPlayerThreshold,
            remainingPlayers: totalPlayerThreshold - playersBought, // Calculate from threshold
            allocatedAmount: parseFloat(row[cols.allocatedAmount]) || 0,
            remainingPurse: remainingPurse,
            highestBid: highestBid,
            captain: row[cols.captain] || '',
            underAgePlayers: underAgePlayers // Read directly from sheet (Column D)
          };
        });
        
        // Sync underAgePlayers count from soldPlayers array as validation/backup
        await syncUnderAgePlayersFromSoldData();
        
        console.debug('[DATA_FETCH] Loaded teams:', teams.length, 'teams with', teams.map(t => t.name).join(', '));
        populateTeamDropdown();
        populateTeamStatusIndicator(); // Initialize team status indicator
        
        // If teams info overlay is open, refresh it
        const teamsInfoOverlay = document.getElementById('teamsInfoOverlay');
        if (teamsInfoOverlay && teamsInfoOverlay.classList.contains('show')) {
          populateTeamsTable();
        }
        
        // If team slots overlay is open, refresh it
        const teamSlotsOverlay = document.getElementById('teamSlotsOverlay');
        if (teamSlotsOverlay && teamSlotsOverlay.classList.contains('show')) {
          // Find which team is currently displayed and refresh it
          const currentTeamName = teamSlotsOverlay.getAttribute('data-current-team');
          if (currentTeamName) {
            const teamIndex = teams.findIndex(t => t.name === currentTeamName);
            if (teamIndex >= 0) {
              showTeamSlots(teamIndex, true); // Pass true to skip recursive refresh
            }
          }
        }
      } catch (error) {
        console.error('Error fetching teams:', error);
        // Load default teams from config if fetch fails
        teams = CONFIG.defaultTeams.map(team => ({...team})); // Clone the default teams
        populateTeamDropdown();
        populateTeamStatusIndicator(); // Initialize team status indicator
      }
    }
    
    // Sync underAgePlayers count from soldPlayers data
    async function syncUnderAgePlayersFromSoldData() {
      console.debug('[SYNC] Starting under-age sync - soldPlayers.length:', soldPlayers.length);
      
      if (!soldPlayers || soldPlayers.length === 0) {
        console.debug('[SYNC] No sold players to sync under-age count from');
        return;
      }
      
      try {
        // Fetch sold players with team information from Sold Players sheet
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(SOLD_SHEET_RANGE)}?key=${API_KEY}`;
        const resp = await fetch(url);
        const data = await resp.json();
        
        if (!data.values || data.values.length === 0) {
          console.debug('[SYNC] No sold players data in sheet');
          return;
        }
        
        console.debug('[SYNC] Sold Players sheet has', data.values.length - 1, 'rows (excluding header)');
        
        const cols = CONFIG.columnMappings.soldPlayers;
        
        // Reset all team under-age counts first
        teams.forEach(team => {
          team.underAgePlayers = 0;
        });
        
        // Count under-age players for each team
        let totalUnderAgeFound = 0;
        for (let i = 1; i < data.values.length; i++) {
          const row = data.values[i];
          const age = row[cols.age] ? parseInt(row[cols.age]) : null;
          const teamName = row[cols.teamName] || '';
          const playerName = row[cols.name] || 'Unknown';
          
          console.debug('[SYNC] Checking player:', playerName, '| Age:', age, '| Team:', teamName);
          
          if (age !== null && age < CONFIG.auction.rules.underAgeLimit && teamName) {
            // Find the team and increment their underAgePlayers count
            const team = teams.find(t => t.name === teamName);
            if (team) {
              team.underAgePlayers = (team.underAgePlayers || 0) + 1;
              totalUnderAgeFound++;
              console.debug('[SYNC] ‚úì Under-age player found! Team', teamName, 'now has', team.underAgePlayers, 'under-age players');
            } else {
              console.warn('[SYNC] ‚úó Team not found:', teamName);
            }
          }
        }
        
        console.debug('[SYNC] ===== SYNC COMPLETE =====');
        console.debug('[SYNC] Total under-age players found:', totalUnderAgeFound);
        console.debug('[SYNC] Team under-age counts:', teams.map(t => `${t.name}: ${t.underAgePlayers || 0}`).join(', '));
      } catch (error) {
        console.error('[SYNC] Error syncing under-age player counts:', error);
      }
    }

    function populateTeamDropdown() {
      const dropdown = document.getElementById('teamDropdown');
      dropdown.innerHTML = '<option value="">-- Select a Team --</option>';
      teams.forEach((team, index) => {
        const option = document.createElement('option');
        option.value = index; // Use array index as value
        
        // Calculate max allowed bid for this team
        const maxBid = AUCTION_RULES.calculateMaxBid(team);
        
        // Display team name with remaining purse and max bid info
        option.textContent = `${team.name} (Purse: ‚Çπ${team.remainingPurse.toLocaleString()} | Max: ‚Çπ${maxBid.toLocaleString()})`;
        
        // Disable team option if they can't afford even the base price
        if (team.playersBought >= team.totalPlayerThreshold || team.remainingPurse < basePrice) {
          option.disabled = true;
          option.textContent += ' - FULL/INSUFFICIENT FUNDS';
        }
        
        dropdown.appendChild(option);
      });
    }

    function convertDriveLinkToDirect(url) {
      if (!url) return '';
      
      // Match various Google Drive URL formats
      // Format 1: https://drive.google.com/open?id=XXXXX
      // Format 2: https://drive.google.com/file/d/XXXXX/view
      // Format 3: https://drive.google.com/uc?id=XXXXX
      const idMatch = url.match(/[?&]id=([a-zA-Z0-9_-]+)/) || 
                      url.match(/\/d\/([a-zA-Z0-9_-]+)/) ||
                      url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
      
      if (idMatch && idMatch[1]) {
        const fileId = idMatch[1];
        console.debug('[IMAGE_CACHE] Converting Google Drive URL to direct link - File ID:', fileId);
        // Use thumbnail format which works better for embedding and is more reliable
        // Use w600 for faster loading (sufficient for 450px circle)
        return `https://drive.google.com/thumbnail?id=${fileId}&sz=w600`;
      }
      
      return url; // fallback to original URL
    }

    function showItem(index) {
      if (items.length === 0) return;
      currentIndex = (index + items.length) % items.length;
      const item = items[currentIndex];
      
      const imageSrc = convertDriveLinkToDirect(item.imageUrl);
      // Use background image from config
      const bgImageSrc = CONFIG.assets.backgroundImage;

      // Set background image
      const card = document.getElementById('card');
      card.style.backgroundImage = `url('${bgImageSrc}')`;

      // Set profile circle image from Google Drive or fallback to placeholder
      const profileImg = document.getElementById('profileImg');
      const avatarConfig = CONFIG.ui.avatarPlaceholder;
      const fallbackUrl = `${avatarConfig.baseUrl}?name=${encodeURIComponent(item.name)}&size=${avatarConfig.cardSize}&background=${avatarConfig.background}&color=${avatarConfig.color}&bold=${avatarConfig.bold}&font-size=${avatarConfig.fontSize}`;
      
      // Remove any existing error handler
      profileImg.onerror = null;
      
      if (imageSrc && imageSrc.trim() !== '') {
        // Check if image is already in cache
        if (imageCache.has(imageSrc)) {
          console.debug('[IMAGE_CACHE] Using cached image for player:', item.name);
          profileImg.src = imageSrc;
        } else {
          // Try to load the Google Drive image
          profileImg.src = imageSrc;
          // Set error handler for fallback
          profileImg.onerror = function() {
            console.warn('Failed to load image from Google Drive, using fallback for:', item.name);
            this.onerror = null; // Prevent infinite loop
            this.src = fallbackUrl;
          };
        }
      } else {
        // Use placeholder if no image URL provided
        profileImg.src = fallbackUrl;
      }
      
      // Preload next 3 player images in background
      preloadNextImages(currentIndex, 3);

      // Update all player information - ID only shows number
      document.getElementById('playerId').textContent = String(item.id).padStart(2, '0');
      
      // Display name with age category
      let nameDisplay = item.name.toUpperCase();
      if (item.age !== null && item.age !== undefined) {
        let ageCategory = '';
        if (item.age < 18) {
          ageCategory = ' (U-18)';
        } else if (item.age >= 18 && item.age <= 35) {
          ageCategory = ` (${item.age})`;
        } else if (item.age > 35) {
          ageCategory = ' (35+)';
        }
        nameDisplay += ageCategory;
      }
      document.getElementById('playerName').textContent = nameDisplay;
      
      document.getElementById('playerRole').textContent = item.role;
      document.getElementById('playerMatches').textContent = item.matches;
      document.getElementById('playerBattingBest').textContent = item.battingBestFigures || 'N/A';
      document.getElementById('playerBowlingBest').textContent = item.bowlingBestFigures || 'N/A';
      
      // Reset bid amount for new player - use player's base price or default
      const playerBasePrice = parseFloat(item.basePrice) || basePrice;
      currentBid = playerBasePrice;
      basePrice = playerBasePrice; // Update global basePrice for current player
      updateBidDisplay();
      
      // Reset bid increment to default
      resetBidIncrement();
      
      // Reset last bidding team
      lastBiddingTeam = null;
      lastBiddingTeamIndex = null;
      clearBidTeamDisplay();
      
      // Reset confirmation mode
      if (isAwaitingConfirmation) {
        hideSellConfirmation();
      }
      
      // hide overlays if visible
      document.getElementById('soldOverlay').classList.remove('show');
      document.getElementById('unsoldOverlay').classList.remove('show');
      
      // Save state after everything is reset and ready
      saveAuctionState();
    }

    function updateBidDisplay() {
      document.getElementById('bidAmount').textContent = '‚Çπ' + currentBid.toLocaleString();
      updateTeamStatusIndicator(); // Update team status colors when bid changes
    }
    
    function updateBidIncrementDisplay() {
      const incrementValueEl = document.getElementById('incrementValue');
      const bidIncrementInfo = document.getElementById('bidIncrementInfo');
      
      incrementValueEl.textContent = `+‚Çπ${currentBidIncrement.toLocaleString()}`;
      
      // Add flash animation
      bidIncrementInfo.classList.add('updated');
      setTimeout(() => {
        bidIncrementInfo.classList.remove('updated');
      }, 300);
    }
    
    function increaseBidIncrement() {
      const config = CONFIG.auction.bidIncrements;
      const newIncrement = currentBidIncrement + config.adjustmentStep;
      
      if (newIncrement <= config.maximum) {
        currentBidIncrement = newIncrement;
        updateBidIncrementDisplay();
        updateTeamStatusIndicator(); // Update team status colors
        showNotification(`Bid increment increased to ‚Çπ${currentBidIncrement.toLocaleString()}`, 'info');
      } else {
        showNotification(`Maximum increment is ‚Çπ${config.maximum.toLocaleString()}`, 'warning');
      }
    }
    
    function decreaseBidIncrement() {
      const config = CONFIG.auction.bidIncrements;
      const newIncrement = currentBidIncrement - config.adjustmentStep;
      
      if (newIncrement >= config.minimum) {
        currentBidIncrement = newIncrement;
        updateBidIncrementDisplay();
        updateTeamStatusIndicator(); // Update team status colors
        showNotification(`Bid increment decreased to ‚Çπ${currentBidIncrement.toLocaleString()}`, 'info');
      } else {
        showNotification(`Minimum increment is ‚Çπ${config.minimum.toLocaleString()}`, 'warning');
      }
    }
    
    function resetBidIncrement() {
      currentBidIncrement = CONFIG.auction.bidIncrements.default;
      updateBidIncrementDisplay();
    }

    function increaseBid(amount) {
      const newBid = currentBid + amount;
      
      // Check if a team is selected for validation
      const teamDropdown = document.getElementById('teamDropdown');
      if (teamDropdown && teamDropdown.value !== '') {
        const selectedTeamIndex = parseInt(teamDropdown.value);
        const selectedTeam = teams[selectedTeamIndex];
        
        if (selectedTeam) {
          // Get player age for validation
          const player = items[currentIndex];
          const playerAge = player ? parseInt(player.age) : null;
          
          // Validate the new bid amount with player age
          const validation = AUCTION_RULES.validateBid(selectedTeam, newBid, basePrice, playerAge);
          
          if (!validation.valid && validation.severity === 'critical') {
            showNotification(validation.message, 'warning');
            return; // Block the bid increase
          }
          
          if (validation.isWarning) {
            showNotification(validation.message, 'warning');
            // Continue with bid increase even with warning
          }
        }
      }
      
      currentBid = newBid;
      updateBidDisplay();
      
      // Add pulse animation
      const bidDisplay = document.getElementById('bidDisplay');
      bidDisplay.classList.add('pulse');
      setTimeout(() => {
        bidDisplay.classList.remove('pulse');
      }, 300);
    }

    function showUnsoldRoundMessage() {
      const card = document.getElementById('card');
      const messageOverlay = document.createElement('div');
      messageOverlay.id = 'unsoldRoundMessage';
      messageOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(10, 10, 10, 0.98) 0%, rgba(20, 20, 20, 0.95) 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.5s ease;
      `;
      
      messageOverlay.innerHTML = `
        <div style="text-align: center; padding: 60px;">
          <div style="font-size: 80px; font-weight: 900; color: #ff9800; margin-bottom: 30px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 30px rgba(255, 152, 0, 0.6);">
            UNSOLD PLAYERS ROUND
          </div>
          <div style="font-size: 36px; color: #fff; margin-bottom: 50px; letter-spacing: 2px;">
            Now showing ${unsoldPlayers.length} player${unsoldPlayers.length > 1 ? 's' : ''} who were not sold
          </div>
          <div style="font-size: 28px; color: #aaa; letter-spacing: 1px;">
            Press any key to continue...
          </div>
        </div>
      `;
      
      card.appendChild(messageOverlay);
      
      // Fade in
      setTimeout(() => {
        messageOverlay.style.opacity = '1';
      }, 50);
      
      // Wait for key press to continue
      const continueHandler = (e) => {
        messageOverlay.style.opacity = '0';
        setTimeout(() => {
          if (messageOverlay.parentNode) {
            messageOverlay.remove();
          }
          isShowingUnsoldRound = true;
          currentIndex = -1;
          showItem(0);
        }, 500);
        document.removeEventListener('keydown', continueHandler);
      };
      
      document.addEventListener('keydown', continueHandler);
    }
    
    function nextItem() {
      // For random mode, check if all available players have been shown in first round
      if (!allPlayersShown && CONFIG.selectionMode.type === 'random') {
        // Check how many players in items array haven't been processed yet
        const unprocessedPlayers = items.filter((item) => {
          const isSold = soldPlayers.some(p => p.id === item.id);
          const isUnsold = unsoldPlayers.some(p => p.id === item.id);
          return !isSold && !isUnsold;
        });
        
        console.debug('[AUCTION_FLOW] === FIRST ROUND CHECK ===');
        console.debug('[AUCTION_FLOW] Items in array:', items.length);
        console.debug('[AUCTION_FLOW] Unprocessed players:', unprocessedPlayers.length, '| IDs:', unprocessedPlayers.map(p => p.id).join(', '));
        console.debug('[AUCTION_FLOW] Sold:', soldPlayers.length, '| Unsold for R2:', unsoldPlayers.length);
        console.debug('[AUCTION_FLOW] Original items:', originalItemCount);
        
        // If NO unprocessed players remain in items array, move to unsold round
        if (unprocessedPlayers.length === 0) {
          allPlayersShown = true;
          
          if (unsoldPlayers.length > 0) {
            console.warn(`[AUCTION_FLOW] ‚ö†Ô∏è TRANSITIONING TO UNSOLD ROUND - All ${items.length} players processed, ${unsoldPlayers.length} unsold players will be shown in second round`);
            // Replace items with unsold players for second round
            items = [...unsoldPlayers];
            showUnsoldRoundMessage();
            return;
          } else {
            // No unsold players - auction complete!
            console.debug('[AUCTION_FLOW] All players sold - Auction complete!');
            showEndScreen();
            return;
          }
        } else {
          console.debug('[AUCTION_FLOW] First round continues - Still', unprocessedPlayers.length, 'unprocessed players in items array');
        }
      }
      
      // For sequential mode, check if we've reached the end of all players in first round
      if (!allPlayersShown && currentIndex >= items.length - 1) {
        allPlayersShown = true;
        
        // Check if there are unsold players
        if (unsoldPlayers.length > 0) {
          console.debug(`[AUCTION_FLOW] First round complete - ${unsoldPlayers.length} unsold players will be shown in second round`);
          // Replace items with unsold players for second round
          items = [...unsoldPlayers];
          showUnsoldRoundMessage();
          return;
        } else {
          // No unsold players - auction complete!
          console.debug('[AUCTION_FLOW] All players sold - Auction complete!');
          showEndScreen();
          return;
        }
      }
      
      // Check if we've reached the end of unsold round
      if (isShowingUnsoldRound) {
        // Count remaining unsold players (not yet sold in this round)
        const remainingUnsoldPlayers = items.filter((item) => {
          const isSold = soldPlayers.some(p => p.id === item.id);
          return !isSold;
        });
        
        console.debug('[AUCTION_FLOW] Unsold round status - Remaining:', remainingUnsoldPlayers.length);
        
        if (remainingUnsoldPlayers.length === 0) {
          console.debug('[AUCTION_FLOW] Unsold round complete - All players have been processed');
          
          // Check if there are still unsold players after second round
          if (unsoldPlayers.length > 0) {
            console.debug(`[AUCTION_FLOW] ${unsoldPlayers.length} players remain unsold - Showing completion prompt`);
            showCompletionPrompt();
          } else {
            console.debug('[AUCTION_FLOW] All players sold after unsold round - Auction complete!');
            showEndScreen();
          }
          return;
        }
      }
      
      // Check selection mode from config
      if (CONFIG.selectionMode.type === 'random') {
        showRandomPlayerSelection();
      } else {
        // Sequential mode - show next player
        showItem(currentIndex + 1);
      }
    }
    
    // Random player selection with coin jar animation
    let isAnimationInProgress = false; // Prevent duplicate calls
    
    function showRandomPlayerSelection() {
      // Prevent duplicate calls while animation is running
      if (isAnimationInProgress) {
        console.debug('[RANDOM_SELECTION] Animation already in progress, skipping duplicate call');
        return;
      }
      
      console.debug('[RANDOM_SELECTION] === RANDOM SELECTION START ===');
      console.debug('[RANDOM_SELECTION] Total items.length:', items.length);
      console.debug('[RANDOM_SELECTION] Sold players:', soldPlayers.length);
      console.debug('[RANDOM_SELECTION] Unsold players:', unsoldPlayers.length);
      console.debug('[RANDOM_SELECTION] Round:', isShowingUnsoldRound ? 'UNSOLD' : 'FIRST');
      console.debug('[RANDOM_SELECTION] Original item count:', originalItemCount);
      
      // Get list of players not yet shown
      // In first round: exclude sold and unsold
      // In unsold round: only exclude sold (we're showing unsold players)
      const availablePlayers = items.filter((item, index) => {
        const isSold = soldPlayers.some(p => p.id === item.id);
        
        if (isShowingUnsoldRound) {
          // In unsold round, only exclude already sold players
          return !isSold;
        } else {
          // In first round, exclude both sold and unsold
          const isUnsold = unsoldPlayers.some(p => p.id === item.id);
          return !isSold && !isUnsold;
        }
      });
      
      console.debug('[RANDOM_SELECTION] Available players for selection:', availablePlayers.length, '| IDs:', availablePlayers.map(p => p.id).join(', '));
      
      if (availablePlayers.length === 0) {
        console.warn('[RANDOM_SELECTION] ‚ö†Ô∏è NO AVAILABLE PLAYERS for random selection');
        
        // Check if we should move to unsold round or end auction
        if (!allPlayersShown && !isShowingUnsoldRound) {
          // Check how many unprocessed players remain in items array
          const unprocessedPlayers = items.filter((item) => {
            const isSold = soldPlayers.some(p => p.id === item.id);
            const isUnsold = unsoldPlayers.some(p => p.id === item.id);
            return !isSold && !isUnsold;
          });
          
          console.debug('[RANDOM_SELECTION] === CHECKING COMPLETION ===');
          console.debug('[RANDOM_SELECTION] Items in array:', items.length);
          console.debug('[RANDOM_SELECTION] Unprocessed players:', unprocessedPlayers.length);
          console.debug('[RANDOM_SELECTION] Sold:', soldPlayers.length, '| Unsold:', unsoldPlayers.length);
          console.debug('[RANDOM_SELECTION] Should move to unsold round?', unprocessedPlayers.length === 0);
          
          if (unprocessedPlayers.length === 0) {
            allPlayersShown = true;
            if (unsoldPlayers.length > 0) {
              console.warn(`[RANDOM_SELECTION] ‚ö†Ô∏è TRANSITIONING TO UNSOLD ROUND from showRandomPlayerSelection - ${unsoldPlayers.length} unsold players`);
              items = [...unsoldPlayers];
              showUnsoldRoundMessage();
              return;
            }
          } else {
            console.error('[RANDOM_SELECTION] ‚ùå ERROR: No available players for selection but', unprocessedPlayers.length, 'unprocessed players still exist!');
            console.error('[RANDOM_SELECTION] Unprocessed player IDs:', unprocessedPlayers.map(p => p.id).join(', '));
            console.error('[RANDOM_SELECTION] This indicates a filtering logic error in availablePlayers calculation');
          }
        }
        
        return;
      }
      
      isAnimationInProgress = true;
      
      // Select random player from available players
      const randomIndex = Math.floor(Math.random() * availablePlayers.length);
      const selectedPlayer = availablePlayers[randomIndex];
      const playerIndex = items.findIndex(p => p.id === selectedPlayer.id);
      
      console.debug(`[RANDOM_SELECTION] Selected player ${selectedPlayer.id} - ${selectedPlayer.name}`);
      
      // Show coin jar animation
      showCoinJarAnimation(selectedPlayer.id, () => {
        // After animation completes, show the selected player
        isAnimationInProgress = false;
        showItem(playerIndex);
      });
    }
    
    // Coin jar animation function
    function showCoinJarAnimation(selectedPlayerId, callback) {
      const overlay = document.getElementById('coinJarOverlay');
      const coinsContainer = document.getElementById('coinsContainer');
      const selectedCoin = document.getElementById('selectedCoin');
      const coinNumber = selectedCoin.querySelector('.coin-number');
      const jarContainer = document.querySelector('.coin-jar-container');
      const jar = document.querySelector('.coin-jar');
      
      // Reset states
      selectedCoin.classList.remove('reveal', 'zoom');
      coinsContainer.classList.remove('shaking');
      jar.classList.remove('shaking');
      jarContainer.classList.remove('fade-out');
      
      // Show overlay with fade in
      overlay.classList.add('show');
      
      // Generate coins for all available players (same logic as showRandomPlayerSelection)
      const availablePlayers = items.filter((item) => {
        const isSold = soldPlayers.some(p => p.id === item.id);
        
        if (isShowingUnsoldRound) {
          // In unsold round, only exclude already sold players
          return !isSold;
        } else {
          // In first round, exclude both sold and unsold
          const isUnsold = unsoldPlayers.some(p => p.id === item.id);
          return !isSold && !isUnsold;
        }
      });
      
      coinsContainer.innerHTML = '';
      
      // Container dimensions - now matches jar-body (380px)
      const containerWidth = 380;
      const containerHeight = 380;
      const coinSize = 45;
      const centerX = containerWidth / 2;
      const centerY = containerHeight / 2;
      const radius = (containerWidth / 2) - coinSize - 20; // Extra margin for safety
      
      availablePlayers.forEach((player, index) => {
        const coin = document.createElement('div');
        coin.className = 'coin';
        coin.textContent = player.id;
        coin.dataset.playerId = player.id;
        
        // Random position at BOTTOM area of circular bowl
        // Use angle range that focuses on bottom portion of circle
        const angle = (Math.PI * 0.25) + (Math.random() * Math.PI * 0.80); // 45¬∞ to 135¬∞ (bottom semicircle)
        const distance = Math.sqrt(Math.random()) * radius * 0.95; // 75% of radius from center (wide spread across jar)
        
        // Calculate position - place coins at very bottom of jar (lower 75% region)
        const randomX = centerX + Math.cos(angle) * distance - (coinSize / 2);
        // Position at bottom - start from 70% down and use sine to create arc at bottom
        const randomY = (containerHeight * 0.70) + Math.abs(Math.sin(angle)) * distance - (coinSize / 2);
        
        const randomRotation = Math.random() * 360;
        const randomSkewX = (Math.random() - 0.5) * 10;
        const randomSkewY = (Math.random() - 0.5) * 10;
        
        // Extensive movement characteristics - spread coins across entire circle
        const bounceHeight = 25 + Math.random() * 50; // 25-75px bounce (increased)
        const bounceDelay = Math.random() * 0.3; // 0-0.3s stagger
        const horizontalDrift = (Math.random() - 0.5) * 80; // -40 to 40px drift (increased significantly)
        
        // Store physics properties as CSS variables
        coin.style.setProperty('--random-x', `${randomX}px`);
        coin.style.setProperty('--random-y', `${randomY}px`);
        coin.style.setProperty('--random-rotation', `${randomRotation}deg`);
        coin.style.setProperty('--random-skewX', `${randomSkewX}deg`);
        coin.style.setProperty('--random-skewY', `${randomSkewY}deg`);
        coin.style.setProperty('--bounce-height', `${bounceHeight}px`);
        coin.style.setProperty('--bounce-delay', `${bounceDelay}s`);
        coin.style.setProperty('--horizontal-drift', `${horizontalDrift}px`);
        
        // Apply initial positioning
        coin.style.left = `${randomX}px`;
        coin.style.top = `${randomY}px`;
        coin.style.transform = `rotate(${randomRotation}deg) skewX(${randomSkewX}deg) skewY(${randomSkewY}deg)`;
        coin.style.zIndex = Math.floor(randomY); // Layer based on depth
        
        coinsContainer.appendChild(coin);
      });
      
      // Start shaking animation with Z-axis rotation
      coinsContainer.classList.add('shaking');
      jar.classList.add('shaking');
      
      // Play coin shake sound during animation
      playCoinShakeSound();
      
      const animConfig = CONFIG.selectionMode.animation;
      
      // After shake duration, stop shaking and reveal selected coin
      setTimeout(() => {
        coinsContainer.classList.remove('shaking');
        jar.classList.remove('shaking');
        
        // Find and highlight the selected coin before revealing
        const allCoins = coinsContainer.querySelectorAll('.coin');
        allCoins.forEach(coin => {
          if (coin.dataset.playerId === String(selectedPlayerId)) {
            coin.classList.add('selected-highlight');
          }
        });
        
        // Set the selected player ID
        coinNumber.textContent = selectedPlayerId;
        
        // Reveal the selected coin with smooth animation
        setTimeout(() => {
          selectedCoin.classList.add('reveal');
        }, 100);
        
        // After reveal, zoom in and transition to player screen
        setTimeout(() => {
          // Add zoom effect
          selectedCoin.classList.add('zoom');
          jarContainer.classList.add('fade-out');
          
          // After zoom animation, hide overlay and show player
          setTimeout(() => {
            selectedCoin.classList.remove('reveal', 'zoom');
            jarContainer.classList.remove('fade-out');
            overlay.classList.remove('show');
            
            // Clear coins
            coinsContainer.innerHTML = '';
            
            // Call callback to show the player with slight delay for smoothness
            if (callback) {
              setTimeout(callback, 100);
            }
          }, 600); // Zoom duration
          
        }, animConfig.coinRevealDuration);
        
      }, animConfig.coinJarShakeDuration);
    }
    
    // Completion prompt and end screen functions
    function showCompletionPrompt() {
      console.debug('[COMPLETION] Showing completion prompt for unsold players');
      const prompt = document.getElementById('completionPrompt');
      prompt.classList.add('show');
    }
    
    function hideCompletionPrompt() {
      const prompt = document.getElementById('completionPrompt');
      prompt.classList.remove('show');
    }
    
    // Next random prompt functions
    function showNextRandomPrompt() {
      console.debug('[RANDOM_SELECTION] Showing next random prompt');
      const prompt = document.getElementById('nextRandomPrompt');
      prompt.classList.add('show');
    }
    
    function hideNextRandomPrompt() {
      const prompt = document.getElementById('nextRandomPrompt');
      prompt.classList.remove('show');
    }
    
    function restartUnsoldAuction() {
      console.debug('[COMPLETION] Restarting auction for unsold players');
      hideCompletionPrompt();
      
      // Reset for another unsold round
      items = [...unsoldPlayers];
      currentIndex = -1;
      
      // Show message
      const messageOverlay = document.createElement('div');
      messageOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255, 87, 34, 0.95) 0%, rgba(244, 67, 54, 0.95) 100%);
        backdrop-filter: blur(10px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9997;
        opacity: 0;
        transition: opacity 0.5s ease;
      `;
      
      const messageContent = document.createElement('div');
      messageContent.style.cssText = `
        text-align: center;
        color: white;
      `;
      messageContent.innerHTML = `
        <div style="font-size: 56px; font-weight: 900; margin-bottom: 20px; text-shadow: 0 4px 20px rgba(0,0,0,0.5);">
          ‚ôªÔ∏è RE-AUCTION
        </div>
        <div style="font-size: 28px; font-weight: 600; opacity: 0.9; text-shadow: 0 2px 10px rgba(0,0,0,0.3);">
          Re-auctioning ${unsoldPlayers.length} Unsold Player${unsoldPlayers.length !== 1 ? 's' : ''}
        </div>
        <div style="font-size: 18px; margin-top: 30px; opacity: 0.8;">
          Press any key to continue
        </div>
      `;
      
      messageOverlay.appendChild(messageContent);
      document.body.appendChild(messageOverlay);
      
      setTimeout(() => {
        messageOverlay.style.opacity = '1';
      }, 100);
      
      // Wait for key press to continue
      const continueHandler = (e) => {
        messageOverlay.style.opacity = '0';
        setTimeout(() => {
          if (messageOverlay.parentNode) {
            messageOverlay.remove();
          }
          currentIndex = -1;
          showItem(0);
        }, 500);
        document.removeEventListener('keydown', continueHandler);
      };
      
      document.addEventListener('keydown', continueHandler);
    }
    
    function showEndScreen() {
      console.debug('[COMPLETION] Showing end screen - Auction complete!');
      hideCompletionPrompt();
      
      // Clear saved state since auction is complete
      clearAuctionState();
      
      const endScreen = document.getElementById('endScreenOverlay');
      endScreen.classList.add('show');
      
      // Play sold sound as celebration
      if (CONFIG.audio.files.sold) {
        const audio = new Audio(CONFIG.audio.files.sold);
        audio.volume = CONFIG.audio.volume;
        audio.play().catch(err => console.debug('[AUDIO] End screen audio play failed:', err));
      }
    }
    
    // Teams Info Overlay Functions
    async function showTeamsInfo() {
      const overlay = document.getElementById('teamsInfoOverlay');
      
      // Show loading state
      const tbody = document.getElementById('teamsTableBody');
      tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding: 40px; color: #888;">Loading teams data...</td></tr>';
      overlay.classList.add('show');
      
      // Refresh team data from sheet to ensure sync
      await fetchTeamsData();
      
      // Now populate with fresh data
      populateTeamsTable();
    }
    
    function hideTeamsInfo() {
      const overlay = document.getElementById('teamsInfoOverlay');
      overlay.classList.remove('show');
    }
    
    // Sell Confirmation Functions (inline mode)
    let isAwaitingConfirmation = false;
    
    function showSellConfirmation() {
      if (!lastBiddingTeam || lastBiddingTeamIndex === null) {
        showNotification('No team has placed a bid yet!', 'warning');
        return;
      }
      
      // Set confirmation mode
      isAwaitingConfirmation = true;
      
      // Show inline hint in bid display
      const bidDisplay = document.getElementById('bidDisplay');
      const confirmHint = document.getElementById('bidConfirmHint');
      const incrementInfo = document.getElementById('bidIncrementInfo');
      
      bidDisplay.classList.add('confirm-mode');
      confirmHint.style.display = 'block';
      
      // Only hide increment info if it's visible (based on config)
      if (CONFIG.notifications.showBidIncrementInfo) {
        incrementInfo.style.display = 'none';
      }
      
      hideBidTeamWarning(); // Hide any warnings during confirmation
      
      // Show color feedback or notification based on config
      if (CONFIG.notifications.useColorFeedback && !CONFIG.notifications.showTopNotifications) {
        // Change bid display to success/green color to indicate ready to confirm
        showColorFeedback('success');
      } else {
        showNotification(`Press ENTER to confirm sale to ${lastBiddingTeam.name}`, 'info');
      }
    }
    
    function hideSellConfirmation() {
      isAwaitingConfirmation = false;
      
      const bidDisplay = document.getElementById('bidDisplay');
      const confirmHint = document.getElementById('bidConfirmHint');
      const incrementInfo = document.getElementById('bidIncrementInfo');
      
      bidDisplay.classList.remove('confirm-mode');
      confirmHint.style.display = 'none';
      
      // Only show increment info if config allows it
      if (CONFIG.notifications.showBidIncrementInfo) {
        incrementInfo.style.display = 'block';
      }
    }
    
    function confirmSale() {
      hideSellConfirmation();
      autoConfirmTeamSelection(lastBiddingTeamIndex);
    }
    
    // Hotkey Helper Functions
    function toggleHotkeyHelper() {
      const overlay = document.getElementById('hotkeyHelperOverlay');
      overlay.classList.toggle('show');
    }
    
    function toggleTeamsInfo() {
      const overlay = document.getElementById('teamsInfoOverlay');
      if (overlay.classList.contains('show')) {
        hideTeamsInfo();
      } else {
        showTeamsInfo();
      }
    }
    
    function populateTeamsTable() {
      const tbody = document.getElementById('teamsTableBody');
      tbody.innerHTML = ''; // Clear existing rows
      
      if (teams.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding: 40px; color: #888;">No teams data available</td></tr>';
        return;
      }
      
      teams.forEach(team => {
        const row = document.createElement('tr');
        
        // Calculate Purse Spent
        const purseSpent = team.allocatedAmount - team.remainingPurse;
        const thresholds = CONFIG.ui.teamStatsThresholds;
        
        // Determine status colors
        let purseSpentClass = 'team-stat-value';
        if (purseSpent > team.allocatedAmount * thresholds.purseSpent.warning) {
          purseSpentClass += ' warning';
        } else if (purseSpent > team.allocatedAmount * thresholds.purseSpent.danger) {
          purseSpentClass += ' danger';
        }
        
        let purseRemainingClass = 'team-stat-value';
        if (team.remainingPurse < thresholds.remainingPurse.danger) {
          purseRemainingClass += ' danger';
        } else if (team.remainingPurse < thresholds.remainingPurse.warning) {
          purseRemainingClass += ' warning';
        }
        
        let playersClass = 'team-stat-value';
        if (team.remainingPlayers <= thresholds.remainingPlayers.danger) {
          playersClass += ' danger';
        } else if (team.remainingPlayers <= thresholds.remainingPlayers.warning) {
          playersClass += ' warning';
        }
        
        // Under-age players status
        let underAgeClass = 'team-stat-value';
        const underAgeCount = team.underAgePlayers || 0;
        const maxUnderAge = AUCTION_RULES.maxUnderAgePlayers;
        if (underAgeCount >= maxUnderAge) {
          underAgeClass += ' danger';
        } else if (underAgeCount === maxUnderAge - 1) {
          underAgeClass += ' warning';
        }
        
        // Create logo cell
        const logoCell = document.createElement('td');
        logoCell.className = 'team-logo-cell';
        if (team.logoUrl && team.logoUrl.trim() !== '') {
          const logoSrc = convertDriveLinkToDirect(team.logoUrl);
          const logoImg = document.createElement('img');
          logoImg.src = logoSrc;
          logoImg.className = 'team-logo-small';
          logoImg.alt = team.name;
          logoImg.onerror = function() {
            this.style.display = 'none';
          };
          logoCell.appendChild(logoImg);
        } else {
          logoCell.innerHTML = '<div style="width:60px;height:60px;background:#333;border-radius:50%;display:flex;align-items:center;justify-content:center;border:3px solid #2196F3;font-size:24px;">üèè</div>';
        }
        
        // Create cells
        row.innerHTML = `
          <td class="team-name-cell">${team.name}</td>
          <td><span class="team-stat-value">${team.playersBought}</span> / ${team.totalPlayerThreshold}</td>
          <td><span class="${underAgeClass}">${underAgeCount}</span> / ${maxUnderAge}</td>
          <td><span class="${playersClass}">${team.remainingPlayers}</span></td>
          <td><span class="${purseSpentClass}">‚Çπ${purseSpent.toLocaleString()}</span></td>
          <td><span class="${purseRemainingClass}">‚Çπ${team.remainingPurse.toLocaleString()}</span></td>
          <td><span class="team-stat-value">‚Çπ${team.highestBid.toLocaleString()}</span></td>
        `;
        
        // Insert logo cell at the beginning
        row.insertBefore(logoCell, row.firstChild);
        
        tbody.appendChild(row);
      });
    }
    
    // Team Slots View Functions
    let teamMenuVisible = false;
    
    function toggleTeamSelectionMenu() {
      const menu = document.getElementById('teamSelectionMenu');
      teamMenuVisible = !teamMenuVisible;
      
      if (teamMenuVisible) {
        populateTeamMenu();
        menu.classList.add('show');
      } else {
        menu.classList.remove('show');
      }
    }
    
    function hideTeamSelectionMenu() {
      const menu = document.getElementById('teamSelectionMenu');
      teamMenuVisible = false;
      menu.classList.remove('show');
    }
    
    function populateTeamMenu() {
      const menuItems = document.getElementById('teamMenuItems');
      menuItems.innerHTML = '';
      
      teams.forEach((team, index) => {
        const item = document.createElement('div');
        item.className = 'team-menu-item';
        item.onclick = () => showTeamSlots(index);
        
        item.innerHTML = `
          <div class="team-menu-number">${index + 1}</div>
          <div class="team-menu-name">${team.name}</div>
        `;
        
        menuItems.appendChild(item);
      });
    }
    
    // Cache for team colors to avoid recalculation
    const teamColorCache = new Map();
    
    // Extract dominant color from team logo
    async function getTeamColorFromLogo(logoUrl) {
      // Check cache first
      if (teamColorCache.has(logoUrl)) {
        return teamColorCache.get(logoUrl);
      }
      
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        
        img.onload = () => {
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let r = 0, g = 0, b = 0, count = 0;
            
            // Sample pixels (every 10th pixel for performance)
            for (let i = 0; i < data.length; i += 40) {
              const red = data[i];
              const green = data[i + 1];
              const blue = data[i + 2];
              const alpha = data[i + 3];
              
              // Skip transparent or very light/dark pixels
              if (alpha > 128 && (red + green + blue) > 100 && (red + green + blue) < 650) {
                r += red;
                g += green;
                b += blue;
                count++;
              }
            }
            
            if (count > 0) {
              const color = {
                r: Math.round(r / count),
                g: Math.round(g / count),
                b: Math.round(b / count)
              };
              teamColorCache.set(logoUrl, color); // Cache the result
              resolve(color);
            } else {
              // Fallback to default blue
              const defaultColor = { r: 33, g: 150, b: 243 };
              teamColorCache.set(logoUrl, defaultColor);
              resolve(defaultColor);
            }
          } catch (err) {
            console.warn('Color extraction failed:', err);
            const defaultColor = { r: 33, g: 150, b: 243 };
            teamColorCache.set(logoUrl, defaultColor);
            resolve(defaultColor);
          }
        };
        
        img.onerror = () => {
          console.warn('Logo failed to load for color extraction');
          const defaultColor = { r: 33, g: 150, b: 243 };
          teamColorCache.set(logoUrl, defaultColor);
          resolve(defaultColor);
        };
        
        img.src = logoUrl;
      });
    }
    
    // Apply team color theme to overlay
    function applyTeamTheme(overlayElement, color) {
      const { r, g, b } = color;
      
      // Base team color
      overlayElement.style.setProperty('--team-color', `rgba(${r}, ${g}, ${b}, 0.6)`);
      
      // Lighter variant (increase RGB values by 20%)
      const lightR = Math.min(255, Math.round(r * 1.2));
      const lightG = Math.min(255, Math.round(g * 1.2));
      const lightB = Math.min(255, Math.round(b * 1.2));
      overlayElement.style.setProperty('--team-color-light', `rgba(${lightR}, ${lightG}, ${lightB}, 0.4)`);
      
      // Border color (medium opacity)
      overlayElement.style.setProperty('--team-color-border', `rgba(${r}, ${g}, ${b}, 0.4)`);
      
      // Glow effect (low opacity for soft shadow)
      overlayElement.style.setProperty('--team-color-glow', `rgba(${r}, ${g}, ${b}, 0.25)`);
    }
    
    // Cache for player stats to avoid multiple API calls
    let playerStatsCache = new Map();
    let allPlayersCache = []; // Cache for all players from sheet (including those without base price)

    // Function to fetch and cache all players from sheet (without base price filter)
    async function fetchAllPlayersForCache() {
      if (allPlayersCache.length > 0) {
        return allPlayersCache; // Return cached data
      }
      
      try {
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(SHEET_RANGE)}?key=${API_KEY}`;
        const resp = await fetch(url);
        const data = await resp.json();
        
        if (!data.values) {
          return [];
        }
        
        const cols = CONFIG.columnMappings.players;
        allPlayersCache = data.values.map((row, index) => {
          const playerId = row[cols.id] || `P${String(index + 1).padStart(3, '0')}`;
          
          return {
            id: playerId,
            imageUrl: row[cols.imageUrl] || '',
            name: row[cols.name] || 'Unknown Player',
            dateOfBirth: row[cols.dateOfBirth] || '',
            role: row[cols.role] || 'Player',
            matches: row[cols.matches] || '0',
            runs: row[cols.runs] || 'N/A',
            wickets: row[cols.wickets] || 'N/A',
            basePrice: row[cols.basePrice] || ''
          };
        });
        
        console.debug('[PLAYER_CACHE] Cached', allPlayersCache.length, 'players');
        return allPlayersCache;
      } catch (error) {
        console.error('Error fetching all players for cache:', error);
        return [];
      }
    }

    // Function to get player stats from cache (checks both items array and all players cache)
    async function getPlayerStatsFromCache(playerId) {
      if (!playerId || playerId.trim() === '') return null;
      
      // Check cache first
      if (playerStatsCache.has(playerId)) {
        return playerStatsCache.get(playerId);
      }
      
      // Try to find in items array first (auction players)
      let player = items.find(item => String(item.id).trim() === String(playerId).trim());
      
      // If not found, fetch from all players cache
      if (!player) {
        const allPlayers = await fetchAllPlayersForCache();
        player = allPlayers.find(item => String(item.id).trim() === String(playerId).trim());
      }
      
      if (player) {
        const stats = {
          matches: player.matches || 'N/A',
          runs: player.runs || 'N/A',
          wickets: player.wickets || 'N/A'
        };
        
        // Cache it
        playerStatsCache.set(playerId, stats);
        return stats;
      }
      
      return null;
    }

    // Function to get captain details (checks both items array and all players cache)
    async function getCaptainDetails(captainId) {
      if (!captainId || captainId.trim() === '') return null;
      
      // Try to find in items array first (auction players)
      let captain = items.find(item => String(item.id).trim() === String(captainId).trim());
      
      // If not found, fetch from all players cache
      if (!captain) {
        const allPlayers = await fetchAllPlayersForCache();
        captain = allPlayers.find(item => String(item.id).trim() === String(captainId).trim());
      }
      
      if (captain) {
        return {
          id: captain.id,
          imageUrl: captain.imageUrl,
          name: captain.name,
          role: captain.role,
          dateOfBirth: captain.dateOfBirth || '',
          stats: {
            matches: captain.matches || 'N/A',
            runs: captain.runs || 'N/A',
            wickets: captain.wickets || 'N/A'
          }
        };
      }
      
      return null;
    }

    async function showTeamSlots(teamIndex, skipRefresh = false) {
      if (teamIndex < 0 || teamIndex >= teams.length) return;
      
      hideTeamSelectionMenu();
      
      const overlay = document.getElementById('teamSlotsOverlay');
      const container = document.getElementById('teamSlotsContainer');
      const teamName = teams[teamIndex].name; // Store team name before refresh
      
      // Store current team name in overlay for refresh purposes
      overlay.setAttribute('data-current-team', teamName);
      
      // Show cricket animation loader
      container.innerHTML = `
        <div class="team-slots-loading">
          <div class="cricket-animation-container">
            <div class="motion-lines">
              <div class="motion-line"></div>
              <div class="motion-line"></div>
              <div class="motion-line"></div>
            </div>
            <div class="cricket-bat"></div>
            <div class="cricket-ball"></div>
          </div>
          <div class="team-slots-loading-text">Loading Squad...</div>
        </div>
      `;
      overlay.classList.add('show');
      
      // Refresh team data from sheet to ensure sync (unless called from fetchTeamsData refresh)
      if (!skipRefresh) {
        await fetchTeamsData();
        
        // Find the team again after refresh (index might have changed)
        const refreshedTeamIndex = teams.findIndex(t => t.name === teamName);
        if (refreshedTeamIndex < 0) {
          container.innerHTML = '<div style="padding:40px;text-align:center;">Team not found</div>';
          return;
        }
        teamIndex = refreshedTeamIndex;
      }
      
      const team = teams[teamIndex];
      
      // Get captain details from cache (now async to support all players)
      const captainDetails = await getCaptainDetails(team.captain);
      
      // Fetch data in parallel for faster loading
      const [soldPlayers, teamColor] = await Promise.all([
        fetchSoldPlayersForTeam(team.name),
        team.logoUrl && team.logoUrl.trim() !== '' 
          ? getTeamColorFromLogo(convertDriveLinkToDirect(team.logoUrl))
          : Promise.resolve({ r: 33, g: 150, b: 243 })
      ]);
      
      // Apply team theme
      applyTeamTheme(overlay, teamColor);
      
      // Generate TBD slots
      const remainingSlots = team.totalPlayerThreshold - soldPlayers.length;
      
      // Calculate total players and determine grid layout
      const totalPlayers = soldPlayers.length + remainingSlots;
      const gridClass = totalPlayers <= CONFIG.ui.teamSlotsGrid.maxPlayersPer6Cols ? 'grid-6-cols' : 'grid-4-cols';
      
      // Build the HTML with two-column layout
      let html = `
        <div class="team-slots-header">
          <div class="team-logo-large">
            ${team.logoUrl && team.logoUrl.trim() !== '' 
              ? `<img src="${convertDriveLinkToDirect(team.logoUrl)}" alt="${team.name}" style="width:100%;height:100%;border-radius:50%;object-fit:cover;" onerror="this.parentElement.innerHTML='üèè'">` 
              : 'üèè'}
          </div>
          <h1 class="team-slots-title">${team.name}</h1>
          <div class="team-stats-summary">
            <div class="team-stat-item">
              <div class="team-stat-label">Players</div>
              <div class="team-stat-number">${soldPlayers.length}/${team.totalPlayerThreshold}</div>
            </div>
            <div class="team-stat-item">
              <div class="team-stat-label">Under-${AUCTION_RULES.underAgeLimit}</div>
              <div class="team-stat-number">${team.underAgePlayers || 0}/${AUCTION_RULES.maxUnderAgePlayers}</div>
            </div>
            <div class="team-stat-item">
              <div class="team-stat-label">Purse Left</div>
              <div class="team-stat-number">‚Çπ${team.remainingPurse.toLocaleString()}</div>
            </div>
            <div class="team-stat-item">
              <div class="team-stat-label">Highest Bid</div>
              <div class="team-stat-number">‚Çπ${team.highestBid.toLocaleString()}</div>
            </div>
          </div>
        </div>
      `;
      
      // Left side: Captain card container
      html += '<div class="captain-card-container">';
      
      let captainCardHTML = '';
      
      // Build captain card for left side if captain details are available
      if (captainDetails) {
        const avatarConfig = CONFIG.ui.avatarPlaceholder;
        const placeholderUrl = `${avatarConfig.baseUrl}?name=${encodeURIComponent(captainDetails.name)}&size=${avatarConfig.teamSlotSize}&background=${avatarConfig.background}&color=${avatarConfig.color}&bold=${avatarConfig.bold}&font-size=${avatarConfig.fontSize}`;
        const avatarUrl = captainDetails.imageUrl 
          ? convertDriveLinkToDirect(captainDetails.imageUrl)
          : placeholderUrl;
        
        // Determine role icon for captain
        const role = (captainDetails.role || 'Captain').toLowerCase();
        let roleIcon = 'üèè'; // Default cricket icon
        if (role.includes('bowler') && role.includes('bat')) {
          roleIcon = 'üèè‚öæ'; // All-rounder
        } else if (role.includes('bowl')) {
          roleIcon = '‚öæ'; // Bowler
        } else if (role.includes('bat')) {
          roleIcon = 'üèè'; // Batsman
        } else if (role.includes('wicket') || role.includes('keeper') || role.includes('wk')) {
          roleIcon = 'üß§'; // Wicket Keeper
        }
        
        // Build stats tooltip (exclude N/A values)
        let statsTooltipHTML = '';
        const stats = captainDetails.stats;
        const statsArray = [
          { label: 'Matches', value: stats.matches },
          { label: 'Innings', value: stats.innings },
          { label: 'Runs', value: stats.runs },
          { label: 'Wickets', value: stats.wickets },
          { label: 'Average', value: stats.average }
        ].filter(stat => stat.value && stat.value !== 'N/A' && stat.value.toString().trim() !== '');
        
        if (statsArray.length > 0) {
          statsTooltipHTML = `
            <div class="player-stats-tooltip">
              <div class="stats-tooltip-title">Cricket Stats</div>
              <div class="stats-tooltip-grid">
                ${statsArray.map(stat => `
                  <div class="stats-tooltip-item">
                    <span class="stats-tooltip-label">${stat.label}</span>
                    <span class="stats-tooltip-value">${stat.value}</span>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        }
        
        captainCardHTML = `
          <div class="player-card captain-card">
            <div class="player-card-image-container">
              <img class="player-card-image" src="${avatarUrl}" alt="${captainDetails.name}" 
                   onerror="this.src='${placeholderUrl}'">
            </div>
            <div class="player-captain-badge">C</div>
            <div class="player-role-icon">${roleIcon}</div>
            <div class="player-card-info">
              <h3 class="player-card-name">${captainDetails.name}</h3>
              <p class="player-card-role">${captainDetails.role || 'Captain'}</p>
            </div>
            ${statsTooltipHTML}
          </div>
        `;
      }
      
      html += captainCardHTML;
      html += '</div>'; // Close captain-card-container
      
      // Right side: Players grid wrapper
      html += '<div class="players-grid-wrapper">';
      html += `<div class="players-grid ${gridClass}">`;
      
      // Add sold players
      if (soldPlayers.length > 0) {
        for (const player of soldPlayers) {
          // Skip captain if already displayed
          if (captainDetails && player.id === captainDetails.id) {
            continue;
          }
          
          const avatarConfig = CONFIG.ui.avatarPlaceholder;
          const placeholderUrl = `${avatarConfig.baseUrl}?name=${encodeURIComponent(player.name)}&size=${avatarConfig.teamSlotSize}&background=${avatarConfig.background}&color=${avatarConfig.color}&bold=${avatarConfig.bold}&font-size=${avatarConfig.fontSize}`;
          const avatarUrl = player.imageUrl 
            ? convertDriveLinkToDirect(player.imageUrl)
            : placeholderUrl;
          
          // Determine role icon
          const role = (player.role || 'Player').toLowerCase();
          let roleIcon = 'üèè'; // Default cricket icon
          if (role.includes('bowler') && role.includes('bat')) {
            roleIcon = 'üèè‚öæ'; // All-rounder: bat and ball
          } else if (role.includes('bowl')) {
            roleIcon = '‚öæ'; // Bowler: ball
          } else if (role.includes('bat')) {
            roleIcon = 'üèè'; // Batsman: bat
          } else if (role.includes('wicket') || role.includes('keeper') || role.includes('wk')) {
            roleIcon = 'üß§'; // Wicket Keeper: glove
          }
          
          // Get player stats from cache (instant, no API call)
          let statsTooltipHTML = '';
          const playerStats = getPlayerStatsFromCache(player.id);
          if (playerStats) {
            const statsArray = [
              { label: 'Matches', value: playerStats.matches },
              { label: 'Runs', value: playerStats.runs },
              { label: 'Wickets', value: playerStats.wickets }
            ].filter(stat => stat.value && stat.value !== 'N/A' && stat.value.toString().trim() !== '');
            
            if (statsArray.length > 0) {
              statsTooltipHTML = `
                <div class="player-stats-tooltip">
                  <div class="stats-tooltip-title">Cricket Stats</div>
                  <div class="stats-tooltip-grid">
                    ${statsArray.map(stat => `
                      <div class="stats-tooltip-item">
                        <span class="stats-tooltip-label">${stat.label}</span>
                        <span class="stats-tooltip-value">${stat.value}</span>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `;
            }
          }
          
          // Check if captain (you may need to add captain info to your data)
          const isCaptain = player.captain === true || player.isCaptain === true;
          const captainBadge = isCaptain ? '<div class="player-captain-badge">C</div>' : '';
          
          html += `
            <div class="player-card">
              <div class="player-card-image-container">
                <img class="player-card-image" src="${avatarUrl}" alt="${player.name}" 
                     onerror="this.src='${placeholderUrl}'">
              </div>
              ${captainBadge}
              <div class="player-card-info">
                <h3 class="player-card-name">${player.name}</h3>
                <p class="player-card-role">${player.role || 'Player'}</p>
              </div>
              <div class="player-card-price">‚Çπ${player.soldAmount.toLocaleString()}</div>
              <div class="player-role-icon">${roleIcon}</div>
              ${statsTooltipHTML}
            </div>
          `;
        }
      }
      
      // Add TBD slots
      if (remainingSlots > 0) {
        for (let i = 0; i < remainingSlots; i++) {
          html += `
            <div class="player-card tbd">
              <div class="player-avatar-tbd">
                <img src="${CONFIG.assets.placeholderMan}" alt="TBD Player">
              </div>
              <h3 class="player-card-name">Slot ${soldPlayers.length + i + 1}</h3>
              <p class="player-card-tbd-text">To Be Decided</p>
            </div>
          `;
        }
      }
      
      html += '</div>'; // Close players-grid
      html += '</div>'; // Close players-grid-wrapper
      
      container.innerHTML = html;
      overlay.classList.add('show');
    }
    
    function hideTeamSlots() {
      const overlay = document.getElementById('teamSlotsOverlay');
      overlay.classList.remove('show');
      overlay.removeAttribute('data-current-team');
    }
    
    async function fetchSoldPlayersForTeam(teamName) {
      try {
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${encodeURIComponent(SOLD_SHEET_RANGE)}?key=${API_KEY}`;
        const resp = await fetch(url);
        const data = await resp.json();
        
        if (!data.values || data.values.length === 0) {
          return [];
        }
        
        const cols = CONFIG.columnMappings.soldPlayers;
        const soldPlayers = [];
        
        // Skip header row
        for (let i = 1; i < data.values.length; i++) {
          const row = data.values[i];
          const playerTeam = row[cols.teamName] || '';
          
          if (playerTeam === teamName) {
            soldPlayers.push({
              id: row[cols.id] || '',
              imageUrl: row[cols.imageUrl] || '',
              name: row[cols.name] || 'Unknown',
              role: row[cols.role] || 'Player',
              soldAmount: parseFloat(row[cols.soldAmount]) || 0,
              soldDate: row[cols.soldDate] || ''
            });
          }
        }
        
        return soldPlayers;
      } catch (error) {
        console.error('Error fetching sold players:', error);
        return [];
      }
    }
    
    // Save sold player data to Google Sheets
    async function saveSoldPlayer(playerData, bidAmount, teamName, teamData) {
      try {
        const soldData = {
          id: playerData.id,
          imageUrl: playerData.imageUrl,
          name: playerData.name,
          role: playerData.role,
          age: playerData.age,
          matches: playerData.matches,
          bestFigures: playerData.bestFigures,
          soldAmount: bidAmount,
          teamName: teamName,
          soldDate: new Date().toISOString(),
          // Team update data - send the ALREADY UPDATED values from teamData
          teamPlayersBought: teamData.playersBought,
          teamU19PlayersBought: teamData.underAgePlayers,
          teamRemainingPlayers: teamData.remainingPlayers,
          teamRemainingPurse: teamData.remainingPurse,
          teamHighestBid: teamData.highestBid
        };
        
        console.debug('[WEBHOOK] Saving sold player:', playerData.name, 'to team:', teamName, 'for bid:', bidAmount);
        console.debug('[WEBHOOK] Team stats being sent:', {
          playersBought: soldData.teamPlayersBought,
          u19PlayersBought: soldData.teamU19PlayersBought,
          remainingPlayers: soldData.teamRemainingPlayers,
          remainingPurse: soldData.teamRemainingPurse,
          highestBid: soldData.teamHighestBid
        });
        
        const webhookUrl = CONFIG.webhook.url;
        
        const response = await fetch(webhookUrl, {
          method: 'POST',
          mode: 'no-cors',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(soldData)
        });
        
        console.debug('[WEBHOOK] Request sent (no-cors mode) - Waiting', CONFIG.webhook.updateDelay / 1000, 'seconds for Google Sheets update...');
        
        // Wait for Google Sheets to update, then refresh teams data
        setTimeout(async () => {
          console.debug('[WEBHOOK] Fetching updated teams data after webhook delay...');
          await fetchTeamsData();
          console.debug('[WEBHOOK] Teams data refreshed successfully');
        }, CONFIG.webhook.updateDelay);
        
        return true;
      } catch (error) {
        console.error('Error saving sold player:', error);
        return false;
      }
    }

    function showTeamSelection() {
      const modal = document.getElementById('teamModal');
      modal.classList.add('show');
      
      // Reset the dropdown selection
      document.getElementById('teamDropdown').value = '';
      document.getElementById('maxBidIndicator').style.display = 'none';
    }
    
    // Auto-confirm team selection (used when 's' is pressed after team bidding)
    function autoConfirmTeamSelection(teamIndex) {
      if (teamIndex < 0 || teamIndex >= teams.length) {
        alert('Invalid team!');
        return;
      }
      
      const selectedTeam = teams[teamIndex];
      const player = items[currentIndex];
      const playerAge = player ? parseInt(player.age) : null;
      
      // Comprehensive auction rules validation with player age
      const validation = AUCTION_RULES.validateBid(selectedTeam, currentBid, basePrice, playerAge);
      
      if (!validation.valid) {
        if (validation.severity === 'critical') {
          alert(validation.message);
          return; // Block the transaction
        } else if (validation.severity === 'warning') {
          // Show warning but allow confirmation
          const proceed = confirm(`${validation.message}\n\nDo you want to proceed anyway?`);
          if (!proceed) {
            return;
          }
        }
      } else if (validation.isWarning) {
        // Show warning message for safe fund threshold
        showNotification(validation.message, 'warning');
      }
      
      // Play sound immediately when confirm is pressed
      playSoldSound();
      
      // Update team data locally FIRST (before sending to webhook)
      selectedTeam.playersBought += 1;
      selectedTeam.remainingPlayers -= 1;
      selectedTeam.remainingPurse -= currentBid;
      if (currentBid > selectedTeam.highestBid) {
        selectedTeam.highestBid = currentBid;
      }
      
      // Increment under-age player count if applicable
      const currentPlayer = items[currentIndex];
      if (currentPlayer && currentPlayer.age && parseInt(currentPlayer.age) < AUCTION_RULES.underAgeLimit) {
        selectedTeam.underAgePlayers = (selectedTeam.underAgePlayers || 0) + 1;
        console.debug('[AUCTION_FLOW] Under-age player sold - Team:', selectedTeam.name, 'Under-age count:', selectedTeam.underAgePlayers);
      }
      
      // Now save to Google Sheets with UPDATED team info
      if (items[currentIndex]) {
        saveSoldPlayer(items[currentIndex], currentBid, selectedTeam.name, selectedTeam);
      }
      
      // Refresh the dropdown to show updated purse values
      populateTeamDropdown();
      
      // Proceed with sold animation, passing the team info
      proceedWithSoldAnimation(selectedTeam, teamIndex);
    }
    
    function confirmTeamSelection() {
      const dropdown = document.getElementById('teamDropdown');
      const selectedTeamIndex = dropdown.value;
      
      if (!selectedTeamIndex && selectedTeamIndex !== '0') {
        alert('Please select a team!');
        return;
      }
      
      const selectedTeam = teams[parseInt(selectedTeamIndex)];
      const player = items[currentIndex];
      const playerAge = player ? parseInt(player.age) : null;
      
      // Comprehensive auction rules validation with player age
      const validation = AUCTION_RULES.validateBid(selectedTeam, currentBid, basePrice, playerAge);
      
      if (!validation.valid) {
        if (validation.severity === 'critical') {
          alert(validation.message);
          return; // Block the transaction
        } else if (validation.severity === 'warning') {
          // Show warning but allow confirmation
          const proceed = confirm(`${validation.message}\n\nDo you want to proceed anyway?`);
          if (!proceed) {
            return;
          }
        }
      } else if (validation.isWarning) {
        // Show warning message for safe fund threshold
        showNotification(validation.message, 'warning');
      }
      
      // Hide team modal
      document.getElementById('teamModal').classList.remove('show');
      
      // Play sound immediately when confirm is pressed
      playSoldSound();
      
      // Update team data locally FIRST (before sending to webhook)
      selectedTeam.playersBought += 1;
      selectedTeam.remainingPlayers -= 1;
      selectedTeam.remainingPurse -= currentBid;
      if (currentBid > selectedTeam.highestBid) {
        selectedTeam.highestBid = currentBid;
      }
      
      // Increment under-age player count if applicable
      const currentPlayer = items[currentIndex];
      if (currentPlayer && currentPlayer.age && parseInt(currentPlayer.age) < AUCTION_RULES.underAgeLimit) {
        selectedTeam.underAgePlayers = (selectedTeam.underAgePlayers || 0) + 1;
        console.debug('[AUCTION_FLOW] Under-age player sold - Team:', selectedTeam.name, 'Under-age count:', selectedTeam.underAgePlayers);
      }
      
      // Now save to Google Sheets with UPDATED team info
      if (items[currentIndex]) {
        saveSoldPlayer(items[currentIndex], currentBid, selectedTeam.name, selectedTeam);
      }
      
      // Save updated state to localStorage (including team stats)
      saveAuctionState();
      
      // Refresh the dropdown to show updated purse values
      populateTeamDropdown();
      
      // Update team status indicator to reflect new team stats
      updateTeamStatusIndicator();
      
      // Proceed with sold animation, passing the team info
      proceedWithSoldAnimation(selectedTeam, selectedTeamIndex);
    }
    
    function cancelTeamSelection() {
      document.getElementById('teamModal').classList.remove('show');
    }
    
    // New function to handle team bidding via keyboard
    function handleTeamBid(teamIndex) {
      if (teamIndex < 0 || teamIndex >= teams.length) {
        showNotification('Invalid team number', 'warning');
        return;
      }
      
      const team = teams[teamIndex];
      
      // Check if the same team is trying to bid consecutively
      if (lastBiddingTeamIndex !== null && lastBiddingTeamIndex === teamIndex) {
        console.debug('[AUCTION_FLOW] Consecutive bid blocked - Team:', team.name, 'must wait for opponent to bid');
        updateBidTeamDisplay(team);
        return;
      }
      
      // First, check if team can bid at all (without increment) - for immediate feedback
      const currentPlayer = items[currentIndex];
      const playerAge = currentPlayer ? parseInt(currentPlayer.age) : null;
      const currentBidValidation = AUCTION_RULES.validateBid(team, currentBid, basePrice, playerAge);
      
      // If team can't even afford current bid, show warning immediately
      if (!currentBidValidation.valid && currentBidValidation.severity === 'critical') {
        showNotification(currentBidValidation.message, 'warning');
        
        // Show warning in bid display with detailed reason
        let warningMessage = '';
        switch(currentBidValidation.ruleId) {
          case 'RULE_001':
            const maxBid = AUCTION_RULES.calculateMaxBid(team);
            warningMessage = `${team.name} cannot bid - Max allowed: ‚Çπ${maxBid.toLocaleString()}`;
            break;
          case 'RULE_003':
            warningMessage = `${team.name} has exhausted budget (‚Çπ${team.allocatedAmount.toLocaleString()})`;
            break;
          case 'RULE_004':
            warningMessage = `${team.name} roster full (${team.totalPlayerThreshold}/${team.totalPlayerThreshold})`;
            break;
          case 'RULE_005':
            warningMessage = `${team.name} insufficient balance (‚Çπ${team.remainingPurse.toLocaleString()} < ‚Çπ${basePrice.toLocaleString()})`;
            break;
          case 'RULE_009':
            warningMessage = `${team.name} has reached max under-${AUCTION_RULES.underAgeLimit} players limit (${AUCTION_RULES.maxUnderAgePlayers} max)`;
            break;
          default:
            warningMessage = `${team.name} cannot place this bid`;
        }
        showBidTeamWarning(warningMessage);
        
        // DO NOT update bid display with team logo - they are not eligible
        // Just show the warning and return
        
        return;
      }
      
      const newBid = currentBid + currentBidIncrement; // Use dynamic increment
      
      // Now validate the new bid with increment
      const validation = AUCTION_RULES.validateBid(team, newBid, basePrice, playerAge);
      
      if (!validation.valid && validation.severity === 'critical') {
        showNotification(validation.message, 'warning');
        
        // Show warning in bid display with detailed reason
        let warningMessage = '';
        switch(validation.ruleId) {
          case 'RULE_001':
            const maxBid = AUCTION_RULES.calculateMaxBid(team);
            warningMessage = `${team.name} cannot bid ‚Çπ${newBid.toLocaleString()} - Max: ‚Çπ${maxBid.toLocaleString()}`;
            break;
          case 'RULE_003':
            warningMessage = `${team.name} would exceed budget with ‚Çπ${newBid.toLocaleString()}`;
            break;
          case 'RULE_004':
            warningMessage = `${team.name} roster full (${team.totalPlayerThreshold}/${team.totalPlayerThreshold})`;
            break;
          case 'RULE_005':
            warningMessage = `${team.name} insufficient balance (‚Çπ${team.remainingPurse.toLocaleString()})`;
            break;
          case 'RULE_009':
            warningMessage = `${team.name} has reached max under-${AUCTION_RULES.underAgeLimit} players limit (${AUCTION_RULES.maxUnderAgePlayers} max)`;
            break;
          default:
            warningMessage = `${team.name} cannot place this bid`;
        }
        showBidTeamWarning(warningMessage);
        
        // DO NOT update bid display with team logo - they are not eligible
        // Just show the warning and return
        
        return;
      }
      
      // Hide any previous warnings
      hideBidTeamWarning();
      
      if (validation.isWarning) {
        showNotification(validation.message, 'warning');
      }
      
      // Update the current bid
      currentBid = newBid;
      updateBidDisplay();
      
      // Add bid to undo history
      addBidToHistory(currentBid, teamIndex, team.name);
      
      // Update last bidding team
      lastBiddingTeam = team;
      lastBiddingTeamIndex = teamIndex;
      
      // Save state after bid is placed
      saveAuctionState();
      
      // Update bid display with team logo
      updateBidTeamDisplay(team);
      
      // Add pulse animation
      const bidDisplay = document.getElementById('bidDisplay');
      bidDisplay.classList.add('pulse');
      setTimeout(() => {
        bidDisplay.classList.remove('pulse');
      }, 300);
      
      // Show notification
      showNotification(`${team.name} bids ‚Çπ${currentBid.toLocaleString()} (+‚Çπ${currentBidIncrement.toLocaleString()})`, 'info');
    }
    
    // Update bid display with team logo and name
    function updateBidTeamDisplay(team) {
      const logoContainer = document.getElementById('bidTeamLogoContainer');
      const logo = document.getElementById('bidTeamLogo');
      const teamName = document.getElementById('bidTeamName');
      const pulse = document.getElementById('bidTeamPulse');
      
      if (team && team.logoUrl) {
        const logoUrl = convertDriveLinkToDirect(team.logoUrl);
        logo.src = logoUrl;
        logo.alt = team.name;
        logo.style.display = 'block';
        teamName.textContent = team.name;
        teamName.style.display = 'block';
        logoContainer.classList.add('active');
        
        // Trigger animation by removing and re-adding
        logo.style.animation = 'none';
        setTimeout(() => {
          logo.style.animation = '';
        }, 10);
      }
    }
    
    // Clear bid team display
    function clearBidTeamDisplay() {
      const logo = document.getElementById('bidTeamLogo');
      const teamName = document.getElementById('bidTeamName');
      const logoContainer = document.getElementById('bidTeamLogoContainer');
      const warning = document.getElementById('bidTeamWarning');
      
      logo.style.display = 'none';
      logo.src = '';
      teamName.style.display = 'none';
      teamName.textContent = '';
      logoContainer.classList.remove('active');
      warning.style.display = 'none';
    }
    
    // Show team warning in bid display
    function showBidTeamWarning(message) {
      const warning = document.getElementById('bidTeamWarning');
      const warningText = document.getElementById('bidTeamWarningText');
      
      warningText.textContent = message;
      warning.style.display = 'flex';
      warning.style.opacity = '1';
      
      // Auto-hide after 3 seconds with fade out
      setTimeout(() => {
        warning.style.transition = 'opacity 0.5s ease-out';
        warning.style.opacity = '0';
        setTimeout(() => {
          warning.style.display = 'none';
          warning.style.transition = '';
        }, 500);
      }, 3000);
    }
    
    // Hide team warning
    function hideBidTeamWarning() {
      const warning = document.getElementById('bidTeamWarning');
      warning.style.display = 'none';
    }
    
    // Populate team status indicator with all teams
    function populateTeamStatusIndicator() {
      const container = document.getElementById('teamStatusIndicator');
      container.innerHTML = '';
      
      teams.forEach((team, index) => {
        const avatarConfig = CONFIG.ui.avatarPlaceholder;
        const fallbackUrl = `${avatarConfig.baseUrl}?name=${encodeURIComponent(team.name.substring(0, 2))}&size=${avatarConfig.teamStatusSize}&background=${avatarConfig.background}&color=${avatarConfig.color}&bold=${avatarConfig.bold}&font-size=${avatarConfig.teamStatusFontSize}`;
        const logoUrl = team.logoUrl && team.logoUrl.trim() !== '' 
          ? convertDriveLinkToDirect(team.logoUrl) 
          : fallbackUrl;
        
        const statusItem = document.createElement('div');
        statusItem.className = 'team-status-item';
        statusItem.setAttribute('data-team-index', index);
        
        statusItem.innerHTML = `
          <img src="${logoUrl}" alt="${team.name}" class="team-status-logo" onerror="this.src='${fallbackUrl}'">
          <div class="team-status-number">${index + 1}</div>
          <div class="team-status-tooltip">
            <strong>${team.name}</strong><br>
            Purse: ‚Çπ${team.remainingPurse.toLocaleString()}<br>
            Players: ${team.playersBought}/${team.totalPlayerThreshold}
          </div>
        `;
        
        container.appendChild(statusItem);
      });
      
      // Initial status update
      updateTeamStatusIndicator();
    }
    
    // Update team status colors based on current bid
    function updateTeamStatusIndicator() {
      if (teams.length === 0) return;
      
      const container = document.getElementById('teamStatusIndicator');
      const statusItems = container.querySelectorAll('.team-status-item');
      
      const nextBid = currentBid + currentBidIncrement;
      const player = items[currentIndex];
      const playerAge = player ? parseInt(player.age) : null;
      
      statusItems.forEach((item, index) => {
        const team = teams[index];
        
        // Remove all status classes
        item.classList.remove('status-safe', 'status-warning', 'status-danger');
        
        // Check if team can bid at all (with player age validation)
        const currentBidValidation = AUCTION_RULES.validateBid(team, currentBid, basePrice, playerAge);
        
        // If team can't afford current bid, mark as danger (red)
        if (!currentBidValidation.valid && currentBidValidation.severity === 'critical') {
          item.classList.add('status-danger');
          
          // Update tooltip with reason
          const tooltip = item.querySelector('.team-status-tooltip');
          const maxBid = AUCTION_RULES.calculateMaxBid(team);
          let reason = '';
          
          switch(currentBidValidation.ruleId) {
            case 'RULE_001':
              reason = `Max: ‚Çπ${maxBid.toLocaleString()}`;
              break;
            case 'RULE_003':
              reason = 'Budget exhausted';
              break;
            case 'RULE_004':
              reason = 'Roster full';
              break;
            case 'RULE_005':
              reason = 'Insufficient balance';
              break;
            case 'RULE_009':
              reason = `Under-${AUCTION_RULES.underAgeLimit} limit reached`;
              break;
            default:
              reason = 'Cannot bid';
          }
          
          tooltip.innerHTML = `
            <strong>${team.name}</strong><br>
            <span style="color: #f44336;">${reason}</span>
          `;
          return;
        }
        
        // Check next bid validation (with player age)
        const nextBidValidation = AUCTION_RULES.validateBid(team, nextBid, basePrice, playerAge);
        
        // If team can't afford next bid increment, mark as warning (orange)
        if (!nextBidValidation.valid && nextBidValidation.severity === 'critical') {
          item.classList.add('status-warning');
          
          // Update tooltip
          const tooltip = item.querySelector('.team-status-tooltip');
          const maxBid = AUCTION_RULES.calculateMaxBid(team);
          tooltip.innerHTML = `
            <strong>${team.name}</strong><br>
            Purse: ‚Çπ${team.remainingPurse.toLocaleString()}<br>
            <span style="color: #ff9800;">Max: ‚Çπ${maxBid.toLocaleString()}</span>
          `;
          return;
        }
        
        // Check for warning conditions (RULE_006)
        if (nextBidValidation.isWarning) {
          item.classList.add('status-warning');
          
          // Update tooltip
          const tooltip = item.querySelector('.team-status-tooltip');
          tooltip.innerHTML = `
            <strong>${team.name}</strong><br>
            Purse: ‚Çπ${team.remainingPurse.toLocaleString()}<br>
            <span style="color: #ff9800;">Entering unsafe range</span>
          `;
          return;
        }
        
        // Otherwise, team is safe (green)
        item.classList.add('status-safe');
        
        // Update tooltip
        const tooltip = item.querySelector('.team-status-tooltip');
        const maxBid = AUCTION_RULES.calculateMaxBid(team);
        tooltip.innerHTML = `
          <strong>${team.name}</strong><br>
          Purse: ‚Çπ${team.remainingPurse.toLocaleString()}<br>
          <span style="color: #4CAF50;">Max: ‚Çπ${maxBid.toLocaleString()}</span>
        `;
      });
    }
    
    function updateMaxBidIndicator() {
      const dropdown = document.getElementById('teamDropdown');
      const selectedTeamIndex = dropdown.value;
      const indicator = document.getElementById('maxBidIndicator');
      const maxBidValue = document.getElementById('maxBidValue');
      
      if (!selectedTeamIndex && selectedTeamIndex !== '0') {
        indicator.style.display = 'none';
        return;
      }
      
      const selectedTeam = teams[parseInt(selectedTeamIndex)];
      const maxBid = AUCTION_RULES.calculateMaxBid(selectedTeam);
      
      maxBidValue.textContent = `‚Çπ${maxBid.toLocaleString()}`;
      indicator.style.display = 'block';
      
      // Change color based on current bid vs max bid
      if (currentBid > maxBid) {
        indicator.style.borderColor = '#f44336';
        indicator.style.background = 'rgba(244, 67, 54, 0.1)';
      } else if (currentBid > maxBid * 0.8) {
        indicator.style.borderColor = '#ff9800';
        indicator.style.background = 'rgba(255, 152, 0, 0.1)';
      } else {
        indicator.style.borderColor = '#2196F3';
        indicator.style.background = 'rgba(33, 150, 243, 0.1)';
      }
    }
    
    function soldOutAnimation() {
      // Show team selection modal instead of directly animating
      showTeamSelection();
    }
    
    function proceedWithSoldAnimation(teamData = null, teamIndex = null) {
      const overlay = document.getElementById('soldOverlay');
      const hammer = document.getElementById('hammer');
      const impact = document.getElementById('impact');
      const stamp = document.getElementById('stamp');
      const stampTeamName = document.getElementById('stampTeamName');
      const card = document.getElementById('card');
      
      // Reset all animations first to prevent glitches
      overlay.classList.remove('show', 'impact');
      hammer.classList.remove('strike');
      impact.classList.remove('show');
      stamp.classList.remove('stamping');
      
      // Set the team name and logo in the stamp
      // Use passed parameters if available, otherwise try to get from dropdown
      let selectedTeam = teamData;
      let selectedTeamIndex = teamIndex;
      
      if (!selectedTeam) {
        selectedTeamIndex = document.getElementById('teamDropdown').value;
        if (selectedTeamIndex !== '' && teams[selectedTeamIndex]) {
          selectedTeam = teams[selectedTeamIndex];
        }
      }
      
      console.debug('[TEAM_SELECTION] Selected team index:', selectedTeamIndex, '| Team:', selectedTeam?.name || 'None');
      
      if (selectedTeam) {
        
        // Set team name with explicit styling to ensure visibility
        stampTeamName.textContent = selectedTeam.name;
        stampTeamName.style.display = 'block';
        stampTeamName.style.visibility = 'visible';
        stampTeamName.style.opacity = '1';
        stampTeamName.style.color = '#4CAF50';
        stampTeamName.style.fontSize = '26px';
        stampTeamName.style.fontWeight = '700';
        stampTeamName.style.textTransform = 'uppercase';
        console.debug('[TEAM_SELECTION] Team stamp name set to:', selectedTeam.name);
        
        // Set team logo as background image if available
        if (selectedTeam.logoUrl && selectedTeam.logoUrl.trim() !== '') {
          const logoSrc = convertDriveLinkToDirect(selectedTeam.logoUrl);
          console.debug('[TEAM_SELECTION] Setting team logo background:', logoSrc.substring(0, 50) + '...');
          
          // Set background properties explicitly
          stamp.style.backgroundImage = `linear-gradient(135deg, rgba(20, 20, 20, 0.25) 0%, rgba(10, 10, 10, 0.40) 100%), url("${logoSrc}")`;
          stamp.style.backgroundSize = 'cover';
          stamp.style.backgroundPosition = 'center';
          stamp.style.backgroundRepeat = 'no-repeat';
          stamp.style.backgroundBlendMode = 'normal';
          
          // Also reduce the stamp-content overlay opacity
          const stampContent = stamp.querySelector('.stamp-content');
          if (stampContent) {
            stampContent.style.background = 'radial-gradient(circle, rgba(0, 0, 0, 0.20) 0%, rgba(0, 0, 0, 0.35) 100%)';
          }
        } else {
          console.debug('[TEAM_SELECTION] No team logo URL provided, using default background');
          stamp.style.backgroundImage = 'linear-gradient(135deg, rgba(20, 20, 20, 0.85) 0%, rgba(10, 10, 10, 0.90) 100%)';
          stamp.style.backgroundSize = 'cover';
          stamp.style.backgroundPosition = 'center';
          stamp.style.backgroundRepeat = 'no-repeat';
          
          // Reset stamp-content overlay
          const stampContent = stamp.querySelector('.stamp-content');
          if (stampContent) {
            stampContent.style.background = 'radial-gradient(circle, rgba(0, 0, 0, 0.30) 0%, rgba(0, 0, 0, 0.50) 100%)';
          }
        }
      } else {
        console.warn('‚ö†Ô∏è No team selected or invalid index');
        stampTeamName.textContent = 'TEAM';
        stampTeamName.style.display = 'block';
        stampTeamName.style.visibility = 'visible';
        stampTeamName.style.opacity = '1';
        stamp.style.backgroundImage = 'linear-gradient(135deg, rgba(20, 20, 20, 0.85) 0%, rgba(10, 10, 10, 0.90) 100%)';
        stamp.style.backgroundSize = 'cover';
        stamp.style.backgroundPosition = 'center';
        stamp.style.backgroundRepeat = 'no-repeat';
        
        // Reset stamp-content overlay
        const stampContent = stamp.querySelector('.stamp-content');
        if (stampContent) {
          stampContent.style.background = 'radial-gradient(circle, rgba(0, 0, 0, 0.30) 0%, rgba(0, 0, 0, 0.50) 100%)';
        }
      }
      
      // Add blur to background content only (not the overlay)
      card.classList.add('blur-background');
      
      // Force reflow to ensure clean state
      void overlay.offsetWidth;
      
      // Show overlay first with smooth fade
      const soldAnim = CONFIG.ui.animations.soldOverlay;
      setTimeout(() => {
        overlay.classList.add('show');
      }, soldAnim.showDelay);
      
      // Start hammer animation after overlay is visible
      setTimeout(() => {
        hammer.classList.add('strike');
      }, soldAnim.hammerStrike);
      
      // Show impact and stamp when hammer hits center
      setTimeout(() => {
        impact.classList.add('show');
        stamp.classList.add('stamping');
        overlay.classList.add('impact'); // Add screen shake
        
        // Remove impact shake after animation
        setTimeout(() => {
          overlay.classList.remove('impact');
        }, soldAnim.impactDuration);
      }, soldAnim.impactDelay);
      
      // Keep sold screen visible and show input after animation
      setTimeout(() => {
        hammer.classList.remove('strike');
        impact.classList.remove('show');
        
        // Mark player as sold
        if (items[currentIndex]) {
          soldPlayers.push(items[currentIndex]);
          console.debug('[AUCTION_FLOW] Player sold:', items[currentIndex].name, '- Total sold:', soldPlayers.length);
          
          // Update Google Sheets
          const soldPlayer = items[currentIndex];
          if (isShowingUnsoldRound) {
            // Player was unsold, now sold in second round - move from unsold to sold sheet
            moveUnsoldToSoldSheet(soldPlayer, lastBiddingTeam, currentBid, basePrice);
          } else {
            // First round sale - add to sold sheet
            updateSoldPlayerSheet(soldPlayer, lastBiddingTeam, currentBid, basePrice);
          }
          
          // Don't save here - will be saved when next player is shown via showItem()
          
          // If in unsold round, remove from both unsold players list AND items array
          if (isShowingUnsoldRound) {
            const soldPlayerId = items[currentIndex].id;
            
            // Remove from unsoldPlayers array
            const unsoldIndex = unsoldPlayers.findIndex(p => p.id === soldPlayerId);
            if (unsoldIndex !== -1) {
              unsoldPlayers.splice(unsoldIndex, 1);
              console.debug('[AUCTION_FLOW] Removed from unsold list - Remaining unsold:', unsoldPlayers.length);
            }
            
            // Remove from items array (so random selection doesn't pick it)
            const itemsIndex = items.findIndex(p => p.id === soldPlayerId);
            if (itemsIndex !== -1) {
              items.splice(itemsIndex, 1);
              console.debug('[AUCTION_FLOW] Removed from items list - Remaining items:', items.length);
              
              // Adjust currentIndex if needed
              if (currentIndex >= items.length && items.length > 0) {
                currentIndex = items.length - 1;
              }
            }
          }
        }
        
        // Show appropriate prompt based on selection mode
        if (CONFIG.selectionMode.type === 'random') {
          showNextRandomPrompt();
        } else {
          showJumpToPlayerInput();
        }
      }, soldAnim.totalDuration);
    }

    function unsoldAnimation() {
      const overlay = document.getElementById('unsoldOverlay');
      const x = document.getElementById('unsoldX');
      const text = document.getElementById('unsoldText');
      const subtext = document.getElementById('unsoldSubtext');
      const card = document.getElementById('card');
      
      // Determine which round this is for the current player
      const currentPlayer = items[currentIndex];
      const playerId = currentPlayer ? currentPlayer.id : null;
      const currentRound = playerId && unsoldRoundCount[playerId] ? unsoldRoundCount[playerId] + 1 : 1;
      
      // Update subtext based on round
      if (currentRound === 1) {
        subtext.textContent = 'Moving to Second Round';
      } else {
        subtext.textContent = 'Removed from Auction (Unsold 2x)';
      }
      
      // Add blur to background content only (not the overlay)
      card.classList.add('blur-background');
      
      // Show overlay
      overlay.classList.add('show');
      
      // Trigger animations in sequence using config timings
      const unsoldAnim = CONFIG.ui.animations.unsoldOverlay;
      setTimeout(() => {
        x.classList.add('animate');
      }, unsoldAnim.xAnimationDelay);
      
      setTimeout(() => {
        text.classList.add('animate');
        playUnsoldSound();
      }, unsoldAnim.textAnimationDelay);
      
      setTimeout(() => {
        subtext.classList.add('animate');
      }, unsoldAnim.subtextDelay);
      
      // Keep unsold screen visible after animation
      setTimeout(() => {
        // Mark player as unsold
        if (items[currentIndex]) {
          const currentPlayer = items[currentIndex];
          const playerId = currentPlayer.id;
          
          // Track unsold round count
          if (!unsoldRoundCount[playerId]) {
            unsoldRoundCount[playerId] = 0;
          }
          unsoldRoundCount[playerId]++;
          
          const currentRound = unsoldRoundCount[playerId];
          console.debug('[AUCTION_FLOW] Player marked as unsold:', currentPlayer.name, '- Round:', currentRound, '- Total unsold:', unsoldPlayers.length);
          
          if (currentRound === 1) {
            // First time unsold - add to unsold list for second round
            if (!isShowingUnsoldRound) {
              unsoldPlayers.push(currentPlayer);
              console.debug('[AUCTION_FLOW] Added to unsold list for second round');
            }
            
            // Update Google Sheets - add to unsold sheet
            updateUnsoldPlayerSheet(currentPlayer, basePrice, 'Round 1');
            
          } else if (currentRound >= 2) {
            // Second time unsold - mark as finally unsold and remove from future rounds
            finallyUnsoldPlayers.push(currentPlayer);
            
            // Remove from unsold players list
            const unsoldIndex = unsoldPlayers.findIndex(p => p.id === playerId);
            if (unsoldIndex !== -1) {
              unsoldPlayers.splice(unsoldIndex, 1);
            }
            
            // Remove from items array
            const itemsIndex = items.findIndex(p => p.id === playerId);
            if (itemsIndex !== -1) {
              items.splice(itemsIndex, 1);
              console.debug('[AUCTION_FLOW] Player removed from auction (unsold 2x) - Remaining items:', items.length);
              
              // Adjust currentIndex if needed
              if (currentIndex >= items.length && items.length > 0) {
                currentIndex = items.length - 1;
              }
            }
            
            // Update Google Sheets - mark as finally unsold
            updateUnsoldPlayerSheet(currentPlayer, basePrice, 'Round 2 - Final');
            
            console.debug('[AUCTION_FLOW] Player finally unsold (2x) - Total finally unsold:', finallyUnsoldPlayers.length);
          }
          
          // Don't save here - will be saved when next player is shown via showItem()
        }
        
        // Show appropriate prompt based on selection mode
        setTimeout(() => {
          if (CONFIG.selectionMode.type === 'random') {
            showNextRandomPrompt();
          } else {
            showJumpToPlayerInput();
          }
        }, unsoldAnim.inputDelay);
      }, unsoldAnim.totalDuration);
    }

    function jumpToPlayer(playerId) {
      // Find player by ID
      const playerIndex = items.findIndex(item => String(item.id) === String(playerId));
      
      if (playerIndex !== -1) {
        console.debug('[AUCTION_FLOW] Jumping to player ID:', playerId, 'at index:', playerIndex);
        
        // Hide sold/unsold overlays when jumping to new player
        clearSoldUnsoldOverlays();
        
        showItem(playerIndex);
      } else {
        console.warn('Player with ID', playerId, 'not found');
        alert(`Player with ID ${playerId} not found!`);
      }
    }
    
    function clearSoldUnsoldOverlays() {
      const card = document.getElementById('card');
      const soldOverlay = document.getElementById('soldOverlay');
      const unsoldOverlay = document.getElementById('unsoldOverlay');
      const hammer = document.getElementById('hammer');
      const impact = document.getElementById('impact');
      const stamp = document.getElementById('stamp');
      const x = document.getElementById('unsoldX');
      const text = document.getElementById('unsoldText');
      const subtext = document.getElementById('unsoldSubtext');
      
      // Hide next random prompt
      hideNextRandomPrompt();
      
      // Clear sold overlay
      soldOverlay.classList.remove('show', 'impact');
      hammer.classList.remove('strike');
      impact.classList.remove('show');
      stamp.classList.remove('stamping');
      
      // Clear unsold overlay
      unsoldOverlay.classList.remove('show');
      x.classList.remove('animate');
      text.classList.remove('animate');
      subtext.classList.remove('animate');
      
      // Remove blur
      card.classList.remove('blur-background');
    }
    
    function returnToCurrentPlayer() {
      // Hide input and clear overlays to show current player normally
      hideJumpToPlayerInput();
      clearSoldUnsoldOverlays();
    }
    
    function showJumpToPlayerInput() {
      const input = document.getElementById('jumpToPlayerInput');
      input.style.opacity = '1';
      input.style.pointerEvents = 'auto';
      input.value = '';
      input.focus();
    }
    
    function hideJumpToPlayerInput() {
      const input = document.getElementById('jumpToPlayerInput');
      input.style.opacity = '0';
      input.style.pointerEvents = 'none';
      input.value = '';
    }

    document.addEventListener('keydown', (e) => {
      // Check if input is focused
      const input = document.getElementById('jumpToPlayerInput');
      const isInputFocused = document.activeElement === input;
      
      // Check if next random prompt is visible
      const nextRandomPrompt = document.getElementById('nextRandomPrompt');
      const isNextRandomPromptVisible = nextRandomPrompt && nextRandomPrompt.classList.contains('show');
      
      // Handle next random prompt - Enter to draw next player
      if (isNextRandomPromptVisible && e.key === 'Enter') {
        console.debug('[RANDOM_SELECTION] Enter pressed - triggering next random draw');
        hideNextRandomPrompt();
        clearSoldUnsoldOverlays();
        // Trigger next item which will call showRandomPlayerSelection
        nextItem();
        e.preventDefault();
        return;
      }
      
      // Handle inline sell confirmation mode
      if (isAwaitingConfirmation) {
        if (e.key === 'Enter') {
          confirmSale();
          e.preventDefault();
          return;
        }
        if (e.key === CONFIG.hotkeys.closeOverlay || e.key === 'Escape') {
          hideSellConfirmation();
          showNotification('Sale cancelled', 'info');
          e.preventDefault();
          return;
        }
        // Block all other keys when confirmation is awaiting
        e.preventDefault();
        return;
      }
      
      // If input is focused, only handle Enter and Escape
      if (isInputFocused) {
        if (e.key === 'Enter') {
          const playerId = input.value.trim();
          if (playerId) {
            jumpToPlayer(playerId);
          }
          hideJumpToPlayerInput();
          e.preventDefault();
          return;
        }
        if (e.key === CONFIG.hotkeys.closeOverlay) {
          returnToCurrentPlayer();
          e.preventDefault();
          return;
        }
        // Allow number input and backspace
        return;
      }
      
      // Normal key handlers when input is not focused - using CONFIG.hotkeys
      const key = e.key.toLowerCase();
      
      // Jump to player
      if (key === CONFIG.hotkeys.jumpToPlayer.toLowerCase()) {
        showJumpToPlayerInput();
        e.preventDefault();
      }
      
      // Show hotkey helper
      if (key === 'h') {
        toggleHotkeyHelper();
        e.preventDefault();
      }
      
      // Show teams info
      if (key === CONFIG.hotkeys.showTeamsInfo.toLowerCase()) {
        toggleTeamsInfo();
        e.preventDefault();
      }
      
      // Show team menu
      if (key === CONFIG.hotkeys.showTeamMenu.toLowerCase()) {
        toggleTeamSelectionMenu();
        e.preventDefault();
      }
      
      // Handle 't' key for team slots prefix
      if (key === 't') {
        tKeyPressed = true;
        // Reset after 1 second if no number is pressed
        if (tKeyTimeout) clearTimeout(tKeyTimeout);
        tKeyTimeout = setTimeout(() => {
          tKeyPressed = false;
        }, 1000);
        e.preventDefault();
        return;
      }
      
      // Team slots shortcuts (t+1 to t+8)
      if (tKeyPressed && e.key >= '1' && e.key <= '8') {
        const teamIndex = parseInt(e.key) - 1;
        if (teamIndex < teams.length) {
          showTeamSlots(teamIndex);
          e.preventDefault();
        }
        tKeyPressed = false;
        if (tKeyTimeout) clearTimeout(tKeyTimeout);
        return;
      }
      
      // Team bidding shortcuts (1-9 for direct bidding)
      if (!tKeyPressed && e.key >= '1' && e.key <= '9') {
        const teamIndex = parseInt(e.key) - 1;
        handleTeamBid(teamIndex);
        e.preventDefault();
        return;
      }
      
      // Next player
      if (key === CONFIG.hotkeys.nextPlayer.toLowerCase()) {
        nextItem();
      }
      
      // Mark sold (shows confirmation overlay)
      if (key === CONFIG.hotkeys.markSold.toLowerCase()) {
        if (lastBiddingTeam && lastBiddingTeamIndex !== null) {
          // Show sell confirmation overlay
          showSellConfirmation();
        } else {
          // Show team selection modal if no team has bid yet
          soldOutAnimation();
        }
      }
      
      // Mark unsold
      if (key === CONFIG.hotkeys.markUnsold.toLowerCase()) {
        unsoldAnimation();
      }
      
      // Bid increment controls - Q decreases, W increases
      if (key === 'q') {
        decreaseBidIncrement();
        e.preventDefault();
      }
      if (key === 'w') {
        increaseBidIncrement();
        e.preventDefault();
      }
      
      // Close overlays with Escape key
      if (e.key === CONFIG.hotkeys.closeOverlay) {
        const hotkeyHelperOverlay = document.getElementById('hotkeyHelperOverlay');
        const teamsInfoOverlay = document.getElementById('teamsInfoOverlay');
        const teamMenuOverlay = document.getElementById('teamMenuOverlay');
        const teamSlotsOverlay = document.getElementById('teamSlotsOverlay');
        
        if (hotkeyHelperOverlay && hotkeyHelperOverlay.classList.contains('show')) {
          toggleHotkeyHelper();
          e.preventDefault();
        } else if (teamsInfoOverlay && teamsInfoOverlay.classList.contains('show')) {
          toggleTeamsInfo();
          e.preventDefault();
        } else if (teamMenuOverlay && teamMenuOverlay.classList.contains('show')) {
          hideTeamSelectionMenu();
          e.preventDefault();
        } else if (teamSlotsOverlay && teamSlotsOverlay.classList.contains('show')) {
          hideTeamSlots();
          e.preventDefault();
        }
      }
      
      // Fullscreen toggle with Spacebar
      if (e.key === ' ' || e.code === 'Space') {
        // Prevent default spacebar behavior (page scroll)
        e.preventDefault();
        toggleFullscreen();
      }
      
      // Undo last bid with 'z' key
      if (key === 'z' && !e.ctrlKey && !e.metaKey) {
        undoLastBid();
        e.preventDefault();
      }
    });

    // Fullscreen toggle function
    function toggleFullscreen() {
      const isFullscreen = document.fullscreenElement || 
                          document.webkitFullscreenElement || 
                          document.mozFullScreenElement || 
                          document.msFullscreenElement;
      
      if (!isFullscreen) {
        // Enter fullscreen
        const elem = document.documentElement;
        let fullscreenPromise;
        
        if (elem.requestFullscreen) {
          fullscreenPromise = elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { // Safari
          fullscreenPromise = elem.webkitRequestFullscreen();
        } else if (elem.mozRequestFullScreen) { // Firefox
          fullscreenPromise = elem.mozRequestFullScreen();
        } else if (elem.msRequestFullscreen) { // IE/Edge
          fullscreenPromise = elem.msRequestFullscreen();
        }
        
        if (fullscreenPromise) {
          fullscreenPromise
            .then(() => {
              showFullscreenNotification('Fullscreen Mode Activated');
            })
            .catch((err) => {
              console.error('Error entering fullscreen:', err);
              showFullscreenNotification('Fullscreen Not Supported');
            });
        } else {
          showFullscreenNotification('Fullscreen Not Supported');
        }
      } else {
        // Exit fullscreen
        let exitPromise;
        
        if (document.exitFullscreen) {
          exitPromise = document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { // Safari
          exitPromise = document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) { // Firefox
          exitPromise = document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) { // IE/Edge
          exitPromise = document.msExitFullscreen();
        }
        
        if (exitPromise) {
          exitPromise
            .then(() => {
              showFullscreenNotification('Fullscreen Mode Deactivated');
            })
            .catch((err) => {
              console.error('Error exiting fullscreen:', err);
            });
        }
      }
    }

    // Show fullscreen notification
    function showFullscreenNotification(message) {
      // Remove existing notification if any
      const existingNotification = document.querySelector('.fullscreen-notification');
      if (existingNotification) {
        existingNotification.remove();
      }

      // Create notification element
      const notification = document.createElement('div');
      notification.className = 'fullscreen-notification';
      notification.textContent = message;
      document.body.appendChild(notification);

      // Trigger animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);

      // Remove notification after 2 seconds
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          notification.remove();
        }, 300);
      }, 2000);
    }

    // General notification function for different types (info, warning, error, success)
    function showNotification(message, type = 'info', duration = 2500) {
      // Check config to see if top notifications should be shown
      if (!CONFIG.notifications.showTopNotifications) {
        // Use color feedback instead of popup notification
        if (CONFIG.notifications.useColorFeedback) {
          showColorFeedback(type);
        }
        return; // Don't show popup
      }
      
      // Remove existing notification if any
      const existingNotification = document.querySelector('.notification');
      if (existingNotification) {
        existingNotification.remove();
      }

      // Create notification element
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);

      // Trigger animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);

      // Remove notification after duration
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          notification.remove();
        }, 300);
      }, duration);
    }
    
    // Color feedback for bid display (alternative to popup notifications)
    function showColorFeedback(type) {
      const bidDisplay = document.getElementById('bidDisplay');
      if (!bidDisplay) return;
      
      // Remove any existing feedback classes
      bidDisplay.classList.remove('feedback-info', 'feedback-success', 'feedback-warning', 'feedback-error');
      
      // Add new feedback class based on type
      bidDisplay.classList.add(`feedback-${type}`);
      
      // Remove after short duration
      setTimeout(() => {
        bidDisplay.classList.remove(`feedback-${type}`);
      }, 800);
    }

    // Global Auction Debug/Utility Object
    // Exposed for console debugging and testing
    window.AuctionDebug = {
      // Get current auction rules
      getRules: () => AUCTION_RULES.getCurrentRules(),
      
      // Log current rules to console
      logRules: () => AUCTION_RULES.logRules(),
      
      // Test bid validation for a specific team
      testBid: (teamIndex, bidAmount) => {
        if (teamIndex < 0 || teamIndex >= teams.length) {
          console.error('Invalid team index. Valid range: 0 -', teams.length - 1);
          return;
        }
        const team = teams[teamIndex];
        const player = items[currentIndex];
        const playerAge = player ? parseInt(player.age) : null;
        const validation = AUCTION_RULES.validateBid(team, bidAmount, basePrice, playerAge);
        console.log('[DEBUG] BID VALIDATION TEST - Team:', team.name, '| Bid:', bidAmount, '| Player Age:', playerAge);
        console.log('[DEBUG] Result:', validation.valid ? '‚úì VALID' : '‚úó INVALID', validation.valid ? '' : '| Reason: ' + validation.message);
        console.log('[DEBUG] Max Allowed Bid:', AUCTION_RULES.calculateMaxBid(team));
        return validation;
      },
      
      // Get all teams status
      getTeamsStatus: () => {
        const player = items[currentIndex];
        const playerAge = player ? parseInt(player.age) : null;
        return teams.map((team, index) => ({
          index,
          name: team.name,
          playersBought: team.playersBought,
          remainingPlayers: team.remainingPlayers,
          remainingPurse: team.remainingPurse,
          underAgePlayers: team.underAgePlayers || 0,
          maxBid: AUCTION_RULES.calculateMaxBid(team),
          canBidCurrent: AUCTION_RULES.validateBid(team, currentBid, basePrice, playerAge).valid
        }));
      },
      
      // Get current state
      getState: () => ({
        currentPlayerIndex: currentIndex,
        currentPlayer: items[currentIndex],
        currentBid,
        basePrice,
        currentBidIncrement,
        lastBiddingTeam: lastBiddingTeam?.name,
        isAwaitingConfirmation,
        unsoldPlayersCount: unsoldPlayers.length,
        soldPlayersCount: soldPlayers.length
      })
    };
    
    // Log initialization message
    console.log('%cüèè Cricket Auction App Initialized', 'color: #2196F3; font-size: 16px; font-weight: bold;');
    console.log('%cDebug utilities available via window.AuctionDebug', 'color: #4CAF50; font-size: 12px;');

    (async function init() {
      // Control bid increment info visibility based on config
      const bidInfoElement = document.getElementById('bidIncrementInfo');
      if (bidInfoElement) {
        bidInfoElement.style.display = CONFIG.notifications.showBidIncrementInfo ? 'block' : 'none';
      }
      
      // Initialize audio without blocking
      initializeAudio();
      
      // Fetch sheet data first (populates soldPlayers array)
      await fetchSheetData();
      
      // Then fetch teams data (syncs under-age counts from soldPlayers)
      await fetchTeamsData();
      
      // Try to restore saved state
      const stateRestored = restoreAuctionState();
      
      // Update undo button state after state restoration
      updateUndoButtonState();
      
      // Check if random mode is enabled
      const startButton = document.getElementById('startButton');
      const resetButton = document.getElementById('resetAuctionButton');
      const startScreenOverlay = document.getElementById('startScreenOverlay');
      
      // Reset button handler
      resetButton.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm('Are you sure you want to reset the auction and start fresh?')) {
          clearAuctionState();
          location.reload();
        }
      });
      
      if (CONFIG.selectionMode.type === 'random') {
        // Show start screen for random mode
        
        // If state was restored, show resume message
        if (stateRestored) {
          startButton.innerHTML = '<span class="start-icon">‚ñ∂</span><span>RESUME AUCTION</span>';
          document.querySelector('.start-screen-hint').textContent = 'Continue from where you left off';
        }
        
        startButton.addEventListener('click', () => {
          // Hide start screen with animation
          startScreenOverlay.classList.add('hidden');
          
          // Remove from DOM after animation completes
          setTimeout(() => {
            startScreenOverlay.remove();
          }, 500);
          
          // Start or resume auction
          if (stateRestored) {
            // Check if the current player was already sold or unsold
            const currentPlayer = items[currentIndex];
            const isAlreadySold = currentPlayer && soldPlayers.some(p => p.id === currentPlayer.id);
            const isAlreadyUnsold = currentPlayer && unsoldPlayers.some(p => p.id === currentPlayer.id);
            
            if (isAlreadySold || isAlreadyUnsold) {
              // Player was already processed - move to next player
              console.debug('[RESUME] Current player already processed (sold/unsold), moving to next player');
              nextItem();
            } else {
              // Save the restored values before showItem resets them
              const savedBid = currentBid;
              const savedBidIncrement = currentBidIncrement;
              const savedLastTeam = lastBiddingTeam;
              const savedLastTeamIndex = lastBiddingTeamIndex;
              
              console.debug('[RESUME] Before showItem - currentBid:', currentBid, 'savedBid:', savedBid, 'lastBiddingTeam:', lastBiddingTeam);
              
              // Show current player
              showItem(currentIndex);
              
              console.debug('[RESUME] After showItem - currentBid:', currentBid);
              
              // Restore all the saved values
              currentBid = savedBid;
              currentBidIncrement = savedBidIncrement;
              lastBiddingTeam = savedLastTeam;
              lastBiddingTeamIndex = savedLastTeamIndex;
              
              console.debug('[RESUME] After restore - currentBid:', currentBid);
              
              // Update all displays
              updateBidDisplay();
              updateBidIncrementDisplay();
              
              // Restore the bidding team display if there was one
              if (lastBiddingTeam) {
                updateBidTeamDisplay(lastBiddingTeam);
              }
            }
          } else {
            nextItem();
          }
          
          // Preload images in background after 1 second (non-blocking)
          setTimeout(() => {
            preloadTeamLogos();
            preloadAllPlayerImages();
          }, 1000);
        });
      } else {
        // Sequential mode - hide start screen and start immediately
        startScreenOverlay.classList.add('hidden');
        startScreenOverlay.remove();
        
        // Start or resume auction
        if (stateRestored) {
          // Check if the current player was already sold or unsold
          const currentPlayer = items[currentIndex];
          const isAlreadySold = currentPlayer && soldPlayers.some(p => p.id === currentPlayer.id);
          const isAlreadyUnsold = currentPlayer && unsoldPlayers.some(p => p.id === currentPlayer.id);
          
          if (isAlreadySold || isAlreadyUnsold) {
            // Player was already processed - move to next player
            console.debug('[RESUME] Sequential - Current player already processed (sold/unsold), moving to next player');
            nextItem();
          } else {
            // Save the restored values before showItem resets them
            const savedBid = currentBid;
            const savedBidIncrement = currentBidIncrement;
            const savedLastTeam = lastBiddingTeam;
            const savedLastTeamIndex = lastBiddingTeamIndex;
            
            console.debug('[RESUME] Sequential - Before showItem - currentBid:', currentBid, 'savedBid:', savedBid, 'lastBiddingTeam:', lastBiddingTeam);
            
            showItem(currentIndex);
            
            console.debug('[RESUME] Sequential - After showItem - currentBid:', currentBid);
            
            // Restore all the saved values
            currentBid = savedBid;
            currentBidIncrement = savedBidIncrement;
            lastBiddingTeam = savedLastTeam;
            lastBiddingTeamIndex = savedLastTeamIndex;
            
            console.debug('[RESUME] Sequential - After restore - currentBid:', currentBid);
            
            // Update all displays
            updateBidDisplay();
            updateBidIncrementDisplay();
            
            // Restore the bidding team display if there was one
            if (lastBiddingTeam) {
              updateBidTeamDisplay(lastBiddingTeam);
            }
          }
        } else {
          nextItem();
        }
        
        // Preload images in background after 1 second (non-blocking)
        setTimeout(() => {
          preloadTeamLogos();
          preloadAllPlayerImages();
        }, 1000);
      }
    })();
  </script>

  <!-- Undo Button (bottom right corner, subtle) -->
  <button id="undoButton" class="undo-button" title="Undo last bid (Z)" onclick="undoLastBid()">
    ‚Ü∂
  </button>

</body>
</html>
